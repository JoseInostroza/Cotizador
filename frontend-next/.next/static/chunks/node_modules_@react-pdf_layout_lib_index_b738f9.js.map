{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Users/anali/OneDrive/Escritorio/programas/Cotizador/frontend-next/node_modules/%40react-pdf/layout/lib/index.js"],"sourcesContent":["import { upperFirst, capitalize, last, without, pick, compose, evolve, mapValues, matchPercent, isNil, get, castArray, omit, asyncCompose } from '@react-pdf/fns';\nimport * as P from '@react-pdf/primitives';\nimport { TextInstance } from '@react-pdf/primitives';\nimport resolveStyle, { transformColor, flatten } from '@react-pdf/stylesheet';\nimport layoutEngine, { wordHyphenation, scriptItemizer, textDecoration, justification, linebreaker, bidi } from '@react-pdf/textkit';\nimport { PDFFont } from '@react-pdf/pdfkit';\nimport * as Yoga from 'yoga-layout/load';\nimport { loadYoga as loadYoga$1 } from 'yoga-layout/load';\nimport emojiRegex from 'emoji-regex';\nimport resolveImage from '@react-pdf/image';\n\n/**\n * Create attributed string from text fragments\n *\n * @param {Object[]} fragments fragments\n * @returns {Object} attributed string\n */\nconst fromFragments = fragments => {\n  let offset = 0;\n  let string = '';\n  const runs = [];\n  fragments.forEach(fragment => {\n    string += fragment.string;\n    runs.push({\n      start: offset,\n      end: offset + fragment.string.length,\n      attributes: fragment.attributes || {}\n    });\n    offset += fragment.string.length;\n  });\n  return {\n    string,\n    runs\n  };\n};\n\n/**\n * Apply transformation to text string\n *\n * @param {string} text\n * @param {string} transformation type\n * @returns {string} transformed text\n */\nconst transformText = (text, transformation) => {\n  switch (transformation) {\n    case 'uppercase':\n      return text.toUpperCase();\n    case 'lowercase':\n      return text.toLowerCase();\n    case 'capitalize':\n      return capitalize(text);\n    case 'upperfirst':\n      return upperFirst(text);\n    default:\n      return text;\n  }\n};\n\nclass StandardFont {\n  constructor(src) {\n    this.name = src;\n    this.src = PDFFont.open(null, src);\n  }\n  encode(str) {\n    return this.src.encode(str);\n  }\n  layout(str) {\n    const [encoded, positions] = this.encode(str);\n    return {\n      positions,\n      stringIndices: positions.map((_, i) => i),\n      glyphs: encoded.map((g, i) => {\n        const glyph = this.getGlyph(parseInt(g, 16));\n        glyph.advanceWidth = positions[i].advanceWidth;\n        return glyph;\n      })\n    };\n  }\n  glyphForCodePoint(codePoint) {\n    const glyph = this.getGlyph(codePoint);\n    glyph.advanceWidth = 400;\n    return glyph;\n  }\n  getGlyph(id) {\n    return {\n      id,\n      _font: this.src,\n      codePoints: [id],\n      isLigature: false,\n      name: this.src.font.characterToGlyph(id)\n    };\n  }\n  hasGlyphForCodePoint(codePoint) {\n    return this.src.font.characterToGlyph(codePoint) !== '.notdef';\n  }\n\n  // Based on empirical observation\n  get ascent() {\n    return 900;\n  }\n\n  // Based on empirical observation\n  get capHeight() {\n    switch (this.name) {\n      case 'Times-Roman':\n      case 'Times-Bold':\n      case 'Times-Italic':\n      case 'Times-BoldItalic':\n        return 650;\n      case 'Courier':\n      case 'Courier-Bold':\n      case 'Courier-Oblique':\n      case 'Courier-BoldOblique':\n        return 550;\n      default:\n        return 690;\n    }\n  }\n\n  // Based on empirical observation\n  get xHeight() {\n    switch (this.name) {\n      case 'Times-Roman':\n      case 'Times-Bold':\n      case 'Times-Italic':\n      case 'Times-BoldItalic':\n        return 440;\n      case 'Courier':\n      case 'Courier-Bold':\n      case 'Courier-Oblique':\n      case 'Courier-BoldOblique':\n        return 390;\n      default:\n        return 490;\n    }\n  }\n\n  // Based on empirical observation\n  get descent() {\n    switch (this.name) {\n      case 'Times-Roman':\n      case 'Times-Bold':\n      case 'Times-Italic':\n      case 'Times-BoldItalic':\n        return -220;\n      case 'Courier':\n      case 'Courier-Bold':\n      case 'Courier-Oblique':\n      case 'Courier-BoldOblique':\n        return -230;\n      default:\n        return -200;\n    }\n  }\n  get lineGap() {\n    return 0;\n  }\n  get unitsPerEm() {\n    return 1000;\n  }\n}\n\nconst fontCache = {};\nconst IGNORED_CODE_POINTS = [173];\nconst getFontSize = node => node.attributes.fontSize || 12;\nconst getOrCreateFont = name => {\n  if (fontCache[name]) return fontCache[name];\n  const font = new StandardFont(name);\n  fontCache[name] = font;\n  return font;\n};\nconst getFallbackFont = () => getOrCreateFont('Helvetica');\nconst pickFontFromFontStack = (codePoint, fontStack, lastFont) => {\n  const fontStackWithFallback = [...fontStack, lastFont, getFallbackFont()];\n  for (let i = 0; i < fontStackWithFallback.length; i += 1) {\n    const font = fontStackWithFallback[i];\n    if (!IGNORED_CODE_POINTS.includes(codePoint) && font && font.hasGlyphForCodePoint && font.hasGlyphForCodePoint(codePoint)) {\n      return font;\n    }\n  }\n  return getFallbackFont();\n};\nconst fontSubstitution = () => _ref => {\n  let {\n    string,\n    runs\n  } = _ref;\n  let lastFont = null;\n  let lastFontSize = null;\n  let lastIndex = 0;\n  let index = 0;\n  const res = [];\n  for (let i = 0; i < runs.length; i += 1) {\n    const run = runs[i];\n    const defaultFont = run.attributes.font.map(font => typeof font === 'string' ? getOrCreateFont(font) : font);\n    if (string.length === 0) {\n      res.push({\n        start: 0,\n        end: 0,\n        attributes: {\n          font: defaultFont\n        }\n      });\n      break;\n    }\n    const chars = string.slice(run.start, run.end);\n    for (let j = 0; j < chars.length; j += 1) {\n      const char = chars[j];\n      const codePoint = char.codePointAt();\n      // If the default font does not have a glyph and the fallback font does, we use it\n      const font = pickFontFromFontStack(codePoint, defaultFont, lastFont);\n      const fontSize = getFontSize(run);\n\n      // If anything that would impact res has changed, update it\n      if (font !== lastFont || fontSize !== lastFontSize || font.unitsPerEm !== lastFont.unitsPerEm) {\n        if (lastFont) {\n          res.push({\n            start: lastIndex,\n            end: index,\n            attributes: {\n              font: lastFont,\n              scale: lastFontSize / lastFont.unitsPerEm\n            }\n          });\n        }\n        lastFont = font;\n        lastFontSize = fontSize;\n        lastIndex = index;\n      }\n      index += char.length;\n    }\n  }\n  if (lastIndex < string.length) {\n    const fontSize = getFontSize(last(runs));\n    res.push({\n      start: lastIndex,\n      end: string.length,\n      attributes: {\n        font: lastFont,\n        scale: fontSize / lastFont.unitsPerEm\n      }\n    });\n  }\n  return {\n    string,\n    runs: res\n  };\n};\n\nconst isTextInstance$4 = node => node.type === P.TextInstance;\nconst engines$1 = {\n  bidi,\n  linebreaker,\n  justification,\n  textDecoration,\n  scriptItemizer,\n  wordHyphenation,\n  fontSubstitution\n};\nconst engine$1 = layoutEngine(engines$1);\nconst getFragments$1 = (fontStore, instance) => {\n  if (!instance) return [{\n    string: ''\n  }];\n  const fragments = [];\n  const {\n    fill = 'black',\n    fontFamily = 'Helvetica',\n    fontWeight,\n    fontStyle,\n    fontSize = 18,\n    textDecorationColor,\n    textDecorationStyle,\n    textTransform,\n    opacity\n  } = instance.props;\n  const _textDecoration = instance.props.textDecoration;\n  const fontFamilies = typeof fontFamily === 'string' ? [fontFamily] : [...(fontFamily || [])];\n  const font = fontFamilies.map(fontFamilyName => {\n    if (typeof fontFamilyName !== 'string') return fontFamilyName;\n    const opts = {\n      fontFamily: fontFamilyName,\n      fontWeight,\n      fontStyle\n    };\n    const obj = fontStore ? fontStore.getFont(opts) : null;\n    return obj ? obj.data : fontFamilyName;\n  });\n  const attributes = {\n    font,\n    opacity,\n    fontSize,\n    color: fill,\n    underlineStyle: textDecorationStyle,\n    underline: _textDecoration === 'underline' || _textDecoration === 'underline line-through' || _textDecoration === 'line-through underline',\n    underlineColor: textDecorationColor || fill,\n    strike: _textDecoration === 'line-through' || _textDecoration === 'underline line-through' || _textDecoration === 'line-through underline',\n    strikeStyle: textDecorationStyle,\n    strikeColor: textDecorationColor || fill\n  };\n  for (let i = 0; i < instance.children.length; i += 1) {\n    const child = instance.children[i];\n    if (isTextInstance$4(child)) {\n      fragments.push({\n        string: transformText(child.value, textTransform),\n        attributes\n      });\n    } else if (child) {\n      fragments.push(...getFragments$1(child));\n    }\n  }\n  return fragments;\n};\nconst getAttributedString$1 = (fontStore, instance) => fromFragments(getFragments$1(fontStore, instance));\nconst AlmostInfinity = 999999999999;\nconst shrinkWhitespaceFactor = {\n  before: -0.5,\n  after: -0.5\n};\nconst layoutTspan = fontStore => (node, xOffset) => {\n  var _node$props;\n  const attributedString = getAttributedString$1(fontStore, node);\n  const x = node.props.x === undefined ? xOffset : node.props.x;\n  const y = ((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.y) || 0;\n  const container = {\n    x,\n    y,\n    width: AlmostInfinity,\n    height: AlmostInfinity\n  };\n  const hyphenationCallback = node.props.hyphenationCallback || (fontStore === null || fontStore === void 0 ? void 0 : fontStore.getHyphenationCallback()) || null;\n  const layoutOptions = {\n    hyphenationCallback,\n    shrinkWhitespaceFactor\n  };\n  const lines = engine$1(attributedString, container, layoutOptions).flat();\n  return Object.assign({}, node, {\n    lines\n  });\n};\n\n// Consecutive <tspan> elements should be joined with a space\nconst joinTSpanLines = node => {\n  const children = node.children.map((child, index) => {\n    const textInstance = child.children[0];\n    if (child.props.x === undefined && index < node.children.length - 1 && textInstance !== null && textInstance !== void 0 && textInstance.value) {\n      return Object.assign({}, child, {\n        children: [{\n          ...textInstance,\n          value: `${textInstance.value} `\n        }]\n      });\n    }\n    return child;\n  }, []);\n  return Object.assign({}, node, {\n    children\n  });\n};\nconst layoutText$1 = (fontStore, node) => {\n  var _node$props2;\n  if (!node.children) return node;\n  let currentXOffset = ((_node$props2 = node.props) === null || _node$props2 === void 0 ? void 0 : _node$props2.x) || 0;\n  const layoutFn = layoutTspan(fontStore);\n  const joinedNode = joinTSpanLines(node);\n  const children = joinedNode.children.map(child => {\n    const childWithLayout = layoutFn(child, currentXOffset);\n    currentXOffset += childWithLayout.lines[0].xAdvance;\n    return childWithLayout;\n  });\n  return Object.assign({}, node, {\n    children\n  });\n};\n\nconst isDefs = node => node.type === P.Defs;\nconst getDefs = node => {\n  const children = node.children || [];\n  const defs = children.find(isDefs) || {};\n  const values = defs.children || [];\n  return values.reduce((acc, value) => {\n    var _value$props;\n    const id = (_value$props = value.props) === null || _value$props === void 0 ? void 0 : _value$props.id;\n    if (id) acc[id] = value;\n    return acc;\n  }, {});\n};\n\nconst isNotDefs = node => node.type !== P.Defs;\nconst detachDefs = node => {\n  if (!node.children) return node;\n  const children = node.children.filter(isNotDefs);\n  return Object.assign({}, node, {\n    children\n  });\n};\nconst URL_REGEX = /url\\(['\"]?#([^'\"]+)['\"]?\\)/;\nconst replaceDef = (defs, value) => {\n  if (!value) return undefined;\n  if (!URL_REGEX.test(value)) return value;\n  const match = value.match(URL_REGEX);\n  return defs[match[1]];\n};\nconst parseNodeDefs = defs => node => {\n  var _node$props, _node$props2;\n  const fill = replaceDef(defs, (_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.fill);\n  const clipPath = replaceDef(defs, (_node$props2 = node.props) === null || _node$props2 === void 0 ? void 0 : _node$props2.clipPath);\n  const props = Object.assign({}, node.props, {\n    fill,\n    clipPath\n  });\n  const children = node.children ? node.children.map(parseNodeDefs(defs)) : undefined;\n  return Object.assign({}, node, {\n    props,\n    children\n  });\n};\nconst parseDefs = root => {\n  if (!root.children) return root;\n  const defs = getDefs(root);\n  const children = root.children.map(parseNodeDefs(defs));\n  return Object.assign({}, root, {\n    children\n  });\n};\nconst replaceDefs = node => {\n  return detachDefs(parseDefs(node));\n};\n\nconst parseViewbox = value => {\n  if (!value) return null;\n  const values = value.split(/[,\\s]+/).map(parseFloat);\n  if (values.length !== 4) return null;\n  return {\n    minX: values[0],\n    minY: values[1],\n    maxX: values[2],\n    maxY: values[3]\n  };\n};\n\nconst getContainer$1 = node => {\n  const viewbox = parseViewbox(node.props.viewBox);\n  if (viewbox) {\n    return {\n      width: viewbox.maxX,\n      height: viewbox.maxY\n    };\n  }\n  if (node.props.width && node.props.height) {\n    return {\n      width: parseFloat(node.props.width),\n      height: parseFloat(node.props.height)\n    };\n  }\n  return {\n    width: 0,\n    height: 0\n  };\n};\n\nconst BASE_SVG_INHERITED_PROPS = ['x', 'y', 'clipPath', 'clipRule', 'opacity', 'fill', 'fillOpacity', 'fillRule', 'stroke', 'strokeLinecap', 'strokeLinejoin', 'strokeOpacity', 'strokeWidth', 'textAnchor', 'dominantBaseline', 'color', 'fontFamily', 'fontSize', 'fontStyle', 'fontWeight', 'letterSpacing', 'opacity', 'textDecoration', 'lineHeight', 'textAlign', 'visibility', 'wordSpacing'];\n\n// Do not inherit \"x\" for <tspan> elements from <text> parent\nconst TEXT_SVG_INHERITED_PROPS = without(['x'], BASE_SVG_INHERITED_PROPS);\nconst SVG_INHERITED_PROPS = {\n  [P.Text]: TEXT_SVG_INHERITED_PROPS\n};\nconst getInheritProps = node => {\n  const props = node.props || {};\n  const svgInheritedProps = SVG_INHERITED_PROPS[node.type] ?? BASE_SVG_INHERITED_PROPS;\n  return pick(svgInheritedProps, props);\n};\nconst inheritProps = node => {\n  if (!node.children) return node;\n  const inheritedProps = getInheritProps(node);\n  const children = node.children.map(child => {\n    const props = Object.assign({}, inheritedProps, child.props || {});\n    const newChild = Object.assign({}, child, {\n      props\n    });\n    return inheritProps(newChild);\n  });\n  return Object.assign({}, node, {\n    children\n  });\n};\n\nconst parseAspectRatio = value => {\n  const match = value.replace(/[\\s\\r\\t\\n]+/gm, ' ').replace(/^defer\\s/, '').split(' ');\n  const align = match[0] || 'xMidYMid';\n  const meetOrSlice = match[1] || 'meet';\n  return {\n    align,\n    meetOrSlice\n  };\n};\n\nconst STYLE_PROPS = ['width', 'height', 'color', 'stroke', 'strokeWidth', 'opacity', 'fillOpacity', 'strokeOpacity', 'fill', 'fillRule', 'clipPath', 'offset', 'transform', 'strokeLinejoin', 'strokeLinecap', 'strokeDasharray'];\nconst VERTICAL_PROPS = ['y', 'y1', 'y2', 'height', 'cy', 'ry'];\nconst HORIZONTAL_PROPS = ['x', 'x1', 'x2', 'width', 'cx', 'rx'];\nconst isType$3 = type => node => node.type === type;\nconst isSvg$3 = isType$3(P.Svg);\nconst isText$5 = isType$3(P.Text);\nconst isTextInstance$3 = isType$3(P.TextInstance);\nconst transformPercent = container => props => mapValues(props, (value, key) => {\n  const match = matchPercent(value);\n  if (match && VERTICAL_PROPS.includes(key)) {\n    return match.percent * container.height;\n  }\n  if (match && HORIZONTAL_PROPS.includes(key)) {\n    return match.percent * container.width;\n  }\n  return value;\n});\nconst parsePercent = value => {\n  const match = matchPercent(value);\n  return match ? match.percent : parseFloat(value);\n};\nconst parseTransform = container => value => {\n  return resolveStyle(container, {\n    transform: value\n  }).transform;\n};\nconst parseProps = container => node => {\n  let props = transformPercent(container)(node.props);\n  props = evolve({\n    x: parseFloat,\n    x1: parseFloat,\n    x2: parseFloat,\n    y: parseFloat,\n    y1: parseFloat,\n    y2: parseFloat,\n    r: parseFloat,\n    rx: parseFloat,\n    ry: parseFloat,\n    cx: parseFloat,\n    cy: parseFloat,\n    width: parseFloat,\n    height: parseFloat,\n    offset: parsePercent,\n    fill: transformColor,\n    opacity: parsePercent,\n    stroke: transformColor,\n    stopOpacity: parsePercent,\n    stopColor: transformColor,\n    transform: parseTransform(container)\n  }, props);\n  return Object.assign({}, node, {\n    props\n  });\n};\nconst mergeStyles$1 = node => {\n  const style = node.style || {};\n  const props = Object.assign({}, style, node.props);\n  return Object.assign({}, node, {\n    props\n  });\n};\nconst removeNoneValues = node => {\n  const removeNone = value => value === 'none' ? null : value;\n  const props = mapValues(node.props, removeNone);\n  return Object.assign({}, node, {\n    props\n  });\n};\nconst pickStyleProps = node => {\n  const props = node.props || {};\n  const styleProps = pick(STYLE_PROPS, props);\n  const style = Object.assign({}, styleProps, node.style || {});\n  return Object.assign({}, node, {\n    style\n  });\n};\nconst parseSvgProps = node => {\n  const props = evolve({\n    width: parseFloat,\n    height: parseFloat,\n    viewBox: parseViewbox,\n    preserveAspectRatio: parseAspectRatio\n  }, node.props);\n  return Object.assign({}, node, {\n    props\n  });\n};\nconst wrapBetweenTspan = node => ({\n  type: P.Tspan,\n  props: {},\n  children: [node]\n});\nconst addMissingTspan = node => {\n  if (!isText$5(node)) return node;\n  if (!node.children) return node;\n  const resolveChild = child => isTextInstance$3(child) ? wrapBetweenTspan(child) : child;\n  const children = node.children.map(resolveChild);\n  return Object.assign({}, node, {\n    children\n  });\n};\nconst parseText = fontStore => node => {\n  if (isText$5(node)) return layoutText$1(fontStore, node);\n  if (!node.children) return node;\n  const children = node.children.map(parseText(fontStore));\n  return Object.assign({}, node, {\n    children\n  });\n};\nconst resolveSvgNode = container => compose(parseProps(container), addMissingTspan, removeNoneValues, mergeStyles$1);\nconst resolveChildren = container => node => {\n  if (!node.children) return node;\n  const resolveChild = compose(resolveChildren(container), resolveSvgNode(container));\n  const children = node.children.map(resolveChild);\n  return Object.assign({}, node, {\n    children\n  });\n};\nconst resolveSvgRoot = (node, fontStore) => {\n  const container = getContainer$1(node);\n  return compose(replaceDefs, parseText(fontStore), parseSvgProps, pickStyleProps, inheritProps, resolveChildren(container))(node);\n};\n\n/**\n * Pre-process SVG nodes so they can be rendered in the next steps\n *\n * @param {Object} node root node\n * @param {Object} fontStore font store\n * @returns {Object} root node\n */\nconst resolveSvg = (node, fontStore) => {\n  if (!node.children) return node;\n  const resolveChild = child => resolveSvg(child, fontStore);\n  const root = isSvg$3(node) ? resolveSvgRoot(node, fontStore) : node;\n  const children = root.children.map(resolveChild);\n  return Object.assign({}, root, {\n    children\n  });\n};\n\nlet instancePromise;\nconst loadYoga = async () => {\n  // Yoga WASM binaries must be asynchronously compiled and loaded\n  // to prevent Event emitter memory leak warnings, Yoga must be loaded only once\n  const instance = await (instancePromise ??= loadYoga$1());\n  const config = instance.Config.create();\n  config.setPointScaleFactor(0);\n  const node = {\n    create: () => instance.Node.createWithConfig(config)\n  };\n  return {\n    node\n  };\n};\n\nconst resolveYoga = async root => {\n  const yoga = await loadYoga();\n  return Object.assign({}, root, {\n    yoga\n  });\n};\n\nconst getZIndex = node => node.style.zIndex;\nconst shouldSort = node => node.type !== P.Document && node.type !== P.Svg;\nconst sortZIndex = (a, b) => {\n  const za = getZIndex(a);\n  const zb = getZIndex(b);\n  if (!za && !zb) return 0;\n  if (!za) return 1;\n  if (!zb) return -1;\n  return zb - za;\n};\n\n/**\n * Sort children by zIndex value\n *\n * @param {Object} node\n * @returns {Object} node\n */\nconst resolveZIndex = node => {\n  if (!node.children) return node;\n  const sortedChildren = shouldSort(node) ? node.children.sort(sortZIndex) : node.children;\n  const children = sortedChildren.map(resolveZIndex);\n  return Object.assign({}, node, {\n    children\n  });\n};\n\n// Caches emoji images data\nconst emojis = {};\nconst regex = emojiRegex();\nconst reflect = promise => function () {\n  return promise(...arguments).then(v => v, e => e);\n};\n\n// Returns a function to be able to mock resolveImage.\nconst makeFetchEmojiImage = () => reflect(resolveImage);\n\n/**\n * When an emoji as no variations, it might still have 2 parts,\n * the canonical emoji and an empty string.\n * ex.\n *   (no color) Array.from('❤️') => [\"❤\", \"️\"]\n *   (w/ color) Array.from('👍🏿') => [\"👍\", \"🏿\"]\n *\n * The empty string needs to be removed otherwise the generated\n * url will be incorect.\n */\nconst _removeVariationSelectors = x => x !== '️';\nconst getCodePoints = (string, withVariationSelectors) => Array.from(string).filter(withVariationSelectors ? () => true : _removeVariationSelectors).map(char => char.codePointAt(0).toString(16)).join('-');\nconst buildEmojiUrl = (emoji, source) => {\n  const {\n    url,\n    format,\n    builder,\n    withVariationSelectors\n  } = source;\n  if (typeof builder === 'function') {\n    return builder(getCodePoints(emoji, withVariationSelectors));\n  }\n  return `${url}${getCodePoints(emoji, withVariationSelectors)}.${format}`;\n};\nconst fetchEmojis = (string, source) => {\n  if (!source || !source.url && !source.builder) return [];\n  const promises = [];\n  Array.from(string.matchAll(regex)).forEach(match => {\n    const emoji = match[0];\n    if (!emojis[emoji] || emojis[emoji].loading) {\n      const emojiUrl = buildEmojiUrl(emoji, source);\n      emojis[emoji] = {\n        loading: true\n      };\n      const fetchEmojiImage = makeFetchEmojiImage();\n      promises.push(fetchEmojiImage({\n        uri: emojiUrl\n      }).then(image => {\n        emojis[emoji].loading = false;\n        emojis[emoji].data = image.data;\n      }));\n    }\n  });\n  return promises;\n};\nconst embedEmojis = fragments => {\n  const result = [];\n  for (let i = 0; i < fragments.length; i += 1) {\n    const fragment = fragments[i];\n    let lastIndex = 0;\n    Array.from(fragment.string.matchAll(regex)).forEach(match => {\n      const {\n        index\n      } = match;\n      const emoji = match[0];\n      const emojiSize = fragment.attributes.fontSize;\n      const chunk = fragment.string.slice(lastIndex, index + match[0].length);\n\n      // If emoji image was found, we create a new fragment with the\n      // correct attachment and object substitution character;\n      if (emojis[emoji] && emojis[emoji].data) {\n        result.push({\n          string: chunk.replace(match, String.fromCharCode(0xfffc)),\n          attributes: {\n            ...fragment.attributes,\n            attachment: {\n              width: emojiSize,\n              height: emojiSize,\n              yOffset: Math.floor(emojiSize * 0.1),\n              image: emojis[emoji].data\n            }\n          }\n        });\n      } else {\n        // If no emoji data, we try to use emojis in the font\n        result.push({\n          string: chunk,\n          attributes: fragment.attributes\n        });\n      }\n      lastIndex = index + emoji.length;\n    });\n    if (lastIndex < fragment.string.length) {\n      result.push({\n        string: fragment.string.slice(lastIndex),\n        attributes: fragment.attributes\n      });\n    }\n  }\n  return result;\n};\n\n/**\n * Get image source\n *\n * @param {Object} node image node\n * @returns {string | Object} image src\n */\nconst getSource = node => {\n  var _node$props, _node$props2, _node$props3;\n  return ((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.src) || ((_node$props2 = node.props) === null || _node$props2 === void 0 ? void 0 : _node$props2.source) || ((_node$props3 = node.props) === null || _node$props3 === void 0 ? void 0 : _node$props3.href);\n};\n\n/**\n * Resolves `src` to `@react-pdf/image` interface.\n *\n * Also it handles factories and async sources.\n *\n * @param {string | Object | Function} src\n * @returns {Promise<Object>} resolved src\n */\nconst resolveSource = async src => {\n  const source = typeof src === 'function' ? await src() : await src;\n  return typeof source === 'string' ? {\n    uri: source\n  } : source;\n};\n\n/**\n * Fetches image and append data to node\n * Ideally this fn should be immutable.\n *\n * @param {Object} node\n */\nconst fetchImage = async node => {\n  const src = getSource(node);\n  const {\n    cache\n  } = node.props;\n  if (!src) {\n    console.warn(false, 'Image should receive either a \"src\" or \"source\" prop');\n    return;\n  }\n  try {\n    const source = await resolveSource(src);\n    if (!source) {\n      throw new Error(`Image's \"src\" or \"source\" prop returned ${source}`);\n    }\n    node.image = await resolveImage(source, {\n      cache\n    });\n    node.image.key = source.data ? source.data.toString() : source.uri;\n  } catch (e) {\n    node.image = {\n      width: 0,\n      height: 0,\n      key: null\n    };\n    console.warn(e.message);\n  }\n};\n\nconst isImage$2 = node => node.type === P.Image;\n\n/**\n * Get all asset promises that need to be resolved\n *\n * @param {Object} fontStore font store\n * @param {Object} node root node\n * @returns {Promise<void>[]} asset promises\n */\nconst fetchAssets = (fontStore, node) => {\n  var _node$children;\n  const promises = [];\n  const listToExplore = ((_node$children = node.children) === null || _node$children === void 0 ? void 0 : _node$children.slice(0)) || [];\n  const emojiSource = fontStore ? fontStore.getEmojiSource() : null;\n  while (listToExplore.length > 0) {\n    var _n$style;\n    const n = listToExplore.shift();\n    if (isImage$2(n)) {\n      promises.push(fetchImage(n));\n    }\n    if (fontStore && (_n$style = n.style) !== null && _n$style !== void 0 && _n$style.fontFamily) {\n      promises.push(fontStore.load(n.style));\n    }\n    if (typeof n === 'string') {\n      promises.push(...fetchEmojis(n, emojiSource));\n    }\n    if (typeof n.value === 'string') {\n      promises.push(...fetchEmojis(n.value, emojiSource));\n    }\n    if (n.children) {\n      n.children.forEach(childNode => {\n        listToExplore.push(childNode);\n      });\n    }\n  }\n  return promises;\n};\n\n/**\n * Fetch image, font and emoji assets in parallel.\n * Layout process will not be resumed until promise resolves.\n *\n * @param {Object} node root node\n * @param {Object} fontStore font store\n * @returns {Promise<Object>} root node\n */\nconst resolveAssets = async (node, fontStore) => {\n  const promises = fetchAssets(fontStore, node);\n  await Promise.all(promises);\n  return node;\n};\n\nconst isLink$1 = node => node.type === P.Link;\nconst DEFAULT_LINK_STYLES = {\n  color: 'blue',\n  textDecoration: 'underline'\n};\n\n/**\n * Computes styles using stylesheet\n *\n * @param {Object} container\n * @param {Object} node document node\n * @returns {Object} computed styles\n */\nconst computeStyle = (container, node) => {\n  let baseStyle = node.style;\n  if (isLink$1(node)) {\n    baseStyle = Array.isArray(node.style) ? [DEFAULT_LINK_STYLES, ...node.style] : [DEFAULT_LINK_STYLES, node.style];\n  }\n  return resolveStyle(container, baseStyle);\n};\n\n/**\n * @typedef {Function} ResolveNodeStyles\n * @param {Object} node document node\n * @returns {Object} node (and subnodes) with resolved styles\n */\n\n/**\n * Resolves node styles\n *\n * @param {Object} container\n * @returns {ResolveNodeStyles} resolve node styles\n */\nconst resolveNodeStyles = container => node => {\n  const style = computeStyle(container, node);\n  if (!node.children) return Object.assign({}, node, {\n    style\n  });\n  const children = node.children.map(resolveNodeStyles(container));\n  return Object.assign({}, node, {\n    style,\n    children\n  });\n};\n\n/**\n * Resolves page styles\n *\n * @param {Object} page document page\n * @returns {Object} document page with resolved styles\n */\nconst resolvePageStyles = page => {\n  var _page$props, _page$box, _page$box2, _page$props2, _page$style;\n  const dpi = ((_page$props = page.props) === null || _page$props === void 0 ? void 0 : _page$props.dpi) || 72;\n  const width = ((_page$box = page.box) === null || _page$box === void 0 ? void 0 : _page$box.width) || page.style.width;\n  const height = ((_page$box2 = page.box) === null || _page$box2 === void 0 ? void 0 : _page$box2.height) || page.style.height;\n  const orientation = ((_page$props2 = page.props) === null || _page$props2 === void 0 ? void 0 : _page$props2.orientation) || 'portrait';\n  const remBase = ((_page$style = page.style) === null || _page$style === void 0 ? void 0 : _page$style.fontSize) || 18;\n  const container = {\n    width,\n    height,\n    orientation,\n    dpi,\n    remBase\n  };\n  return resolveNodeStyles(container)(page);\n};\n\n/**\n * Resolves document styles\n *\n * @param {Object} root document root\n * @returns {Object} document root with resolved styles\n */\nconst resolveStyles = root => {\n  if (!root.children) return root;\n  const children = root.children.map(resolvePageStyles);\n  return Object.assign({}, root, {\n    children\n  });\n};\n\nconst getTransformStyle = s => node => {\n  var _node$style, _node$style2;\n  return isNil((_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style[s]) ? '50%' : (_node$style2 = node.style) === null || _node$style2 === void 0 ? void 0 : _node$style2[s];\n};\n\n/**\n * Get node origin\n *\n * @param {Object} node\n * @returns {{ left?: number, top?: number }} node origin\n */\nconst getOrigin = node => {\n  if (!node.box) return {};\n  const {\n    left,\n    top,\n    width,\n    height\n  } = node.box;\n  const transformOriginX = getTransformStyle('transformOriginX')(node);\n  const transformOriginY = getTransformStyle('transformOriginY')(node);\n  const percentX = matchPercent(transformOriginX);\n  const percentY = matchPercent(transformOriginY);\n  const offsetX = percentX ? width * percentX.percent : transformOriginX;\n  const offsetY = percentY ? height * percentY.percent : transformOriginY;\n  return {\n    left: left + offsetX,\n    top: top + offsetY\n  };\n};\n\n/**\n * Resolve node origin\n *\n * @param {Object} node\n * @returns {Object} node with origin attribute\n */\nconst resolveNodeOrigin = node => {\n  const origin = getOrigin(node);\n  const newNode = Object.assign({}, node, {\n    origin\n  });\n  if (!node.children) return newNode;\n  const children = node.children.map(resolveNodeOrigin);\n  return Object.assign({}, newNode, {\n    children\n  });\n};\n\n/**\n * Resolve document origins\n *\n * @param {Object} root document root\n * @returns {Object} document root\n */\n\nconst resolveOrigin = root => {\n  if (!root.children) return root;\n  const children = root.children.map(resolveNodeOrigin);\n  return Object.assign({}, root, {\n    children\n  });\n};\n\nconst getBookmarkValue = title => {\n  return typeof title === 'string' ? {\n    title,\n    fit: false,\n    expanded: false\n  } : title;\n};\nconst resolveBookmarks = node => {\n  let refs = 0;\n  const children = (node.children || []).slice(0);\n  const listToExplore = children.map(value => ({\n    value,\n    parent: null\n  }));\n  while (listToExplore.length > 0) {\n    var _child$props;\n    const element = listToExplore.shift();\n    const child = element.value;\n    let parent = element.parent;\n    if ((_child$props = child.props) !== null && _child$props !== void 0 && _child$props.bookmark) {\n      var _parent;\n      const bookmark = getBookmarkValue(child.props.bookmark);\n      const ref = refs++;\n      const newHierarchy = {\n        ref,\n        parent: (_parent = parent) === null || _parent === void 0 ? void 0 : _parent.ref,\n        ...bookmark\n      };\n      child.props.bookmark = newHierarchy;\n      parent = newHierarchy;\n    }\n    if (child.children) {\n      child.children.forEach(childNode => {\n        listToExplore.push({\n          value: childNode,\n          parent\n        });\n      });\n    }\n  }\n  return node;\n};\n\nconst VALID_ORIENTATIONS = ['portrait', 'landscape'];\n\n/**\n * Get page orientation. Defaults to portrait\n *\n * @param {Object} page object\n * @returns {string} page orientation\n */\nconst getOrientation = page => {\n  var _page$props;\n  const value = ((_page$props = page.props) === null || _page$props === void 0 ? void 0 : _page$props.orientation) || 'portrait';\n  return VALID_ORIENTATIONS.includes(value) ? value : 'portrait';\n};\n\n/**\n * Return true if page is landscape\n *\n * @param {Object} page instance\n * @returns {boolean} is page landscape\n */\nconst isLandscape = page => getOrientation(page) === 'landscape';\n\n// Page sizes for 72dpi. 72dpi is used internally by pdfkit.\nconst PAGE_SIZES = {\n  '4A0': [4767.87, 6740.79],\n  '2A0': [3370.39, 4767.87],\n  A0: [2383.94, 3370.39],\n  A1: [1683.78, 2383.94],\n  A2: [1190.55, 1683.78],\n  A3: [841.89, 1190.55],\n  A4: [595.28, 841.89],\n  A5: [419.53, 595.28],\n  A6: [297.64, 419.53],\n  A7: [209.76, 297.64],\n  A8: [147.4, 209.76],\n  A9: [104.88, 147.4],\n  A10: [73.7, 104.88],\n  B0: [2834.65, 4008.19],\n  B1: [2004.09, 2834.65],\n  B2: [1417.32, 2004.09],\n  B3: [1000.63, 1417.32],\n  B4: [708.66, 1000.63],\n  B5: [498.9, 708.66],\n  B6: [354.33, 498.9],\n  B7: [249.45, 354.33],\n  B8: [175.75, 249.45],\n  B9: [124.72, 175.75],\n  B10: [87.87, 124.72],\n  C0: [2599.37, 3676.54],\n  C1: [1836.85, 2599.37],\n  C2: [1298.27, 1836.85],\n  C3: [918.43, 1298.27],\n  C4: [649.13, 918.43],\n  C5: [459.21, 649.13],\n  C6: [323.15, 459.21],\n  C7: [229.61, 323.15],\n  C8: [161.57, 229.61],\n  C9: [113.39, 161.57],\n  C10: [79.37, 113.39],\n  RA0: [2437.8, 3458.27],\n  RA1: [1729.13, 2437.8],\n  RA2: [1218.9, 1729.13],\n  RA3: [864.57, 1218.9],\n  RA4: [609.45, 864.57],\n  SRA0: [2551.18, 3628.35],\n  SRA1: [1814.17, 2551.18],\n  SRA2: [1275.59, 1814.17],\n  SRA3: [907.09, 1275.59],\n  SRA4: [637.8, 907.09],\n  EXECUTIVE: [521.86, 756.0],\n  FOLIO: [612.0, 936.0],\n  LEGAL: [612.0, 1008.0],\n  LETTER: [612.0, 792.0],\n  TABLOID: [792.0, 1224.0],\n  ID1: [153, 243]\n};\n\n/**\n * Parses scalar value in value and unit pairs\n *\n * @param {string} value scalar value\n * @returns {Object} parsed value\n */\nconst parseValue = value => {\n  const match = /^(-?\\d*\\.?\\d+)(in|mm|cm|pt|px)?$/g.exec(value);\n  return match ? {\n    value: parseFloat(match[1]),\n    unit: match[2] || 'pt'\n  } : {\n    value,\n    unit: undefined\n  };\n};\n\n/**\n * Transform given scalar value to 72dpi equivalent of size\n *\n * @param {string} value styles value\n * @param {number} inputDpi user defined dpi\n * @returns {Object} transformed value\n */\nconst transformUnit = (value, inputDpi) => {\n  const scalar = parseValue(value);\n  const outputDpi = 72;\n  const mmFactor = 1 / 25.4 * outputDpi;\n  const cmFactor = 1 / 2.54 * outputDpi;\n  switch (scalar.unit) {\n    case 'in':\n      return scalar.value * outputDpi;\n    case 'mm':\n      return scalar.value * mmFactor;\n    case 'cm':\n      return scalar.value * cmFactor;\n    case 'px':\n      return Math.round(scalar.value * (outputDpi / inputDpi));\n    default:\n      return scalar.value;\n  }\n};\nconst transformUnits = (_ref, dpi) => {\n  let {\n    width,\n    height\n  } = _ref;\n  return {\n    width: transformUnit(width, dpi),\n    height: transformUnit(height, dpi)\n  };\n};\n\n/**\n * Transforms array into size object\n *\n * @param {number[] | string[]} v array\n * @returns {{ width: number | string, height: number | string }} size object with width and height\n */\nconst toSizeObject = v => ({\n  width: v[0],\n  height: v[1]\n});\n\n/**\n * Flip size object\n *\n * @param {{ width: number, height: number }} v size object\n * @returns {{ width: number, height: number }} flipped size object\n */\nconst flipSizeObject = v => ({\n  width: v.height,\n  height: v.width\n});\n\n/**\n * Returns size object from a given string\n *\n * @param {string} v page size string\n * @returns {{ width: number, height: number }} size object with width and height\n */\nconst getStringSize = v => {\n  return toSizeObject(PAGE_SIZES[v.toUpperCase()]);\n};\n\n/**\n * Returns size object from a single number\n *\n * @param {number|string} n page size number\n * @returns {{ width: number|string, height: number|string }} size object with width and height\n */\nconst getNumberSize = n => toSizeObject([n, n]);\n\n/**\n * Return page size in an object { width, height }\n *\n * @param {Object} page instance\n * @returns {{ width: number, height: number }} size object with width and height\n */\nconst getSize = page => {\n  var _page$props, _page$props2;\n  const value = ((_page$props = page.props) === null || _page$props === void 0 ? void 0 : _page$props.size) || 'A4';\n  const dpi = parseFloat(((_page$props2 = page.props) === null || _page$props2 === void 0 ? void 0 : _page$props2.dpi) || 72);\n  const type = typeof value;\n\n  /**\n   * @type {{ width: number, height: number }}\n   */\n  let size;\n  if (type === 'string') {\n    size = getStringSize(value);\n  } else if (Array.isArray(value)) {\n    size = transformUnits(toSizeObject(value), dpi);\n  } else if (type === 'number') {\n    size = transformUnits(getNumberSize(value), dpi);\n  } else {\n    size = transformUnits(value, dpi);\n  }\n  return isLandscape(page) ? flipSizeObject(size) : size;\n};\n\n/**\n * Resolves page size\n *\n * @param {Object} page\n * @returns {Object} page with resolved size in style attribute\n */\nconst resolvePageSize = page => {\n  const size = getSize(page);\n  const style = flatten(page.style || {});\n  const box = page.box || {};\n  return {\n    ...page,\n    box,\n    style: {\n      ...style,\n      ...size\n    }\n  };\n};\n\n/**\n * Resolves page sizes\n *\n * @param {Object} root document root\n * @returns {Object} document root with resolved page sizes\n */\nconst resolvePageSizes = root => {\n  if (!root.children) return root;\n  const children = root.children.map(resolvePageSize);\n  return Object.assign({}, root, {\n    children\n  });\n};\n\nconst isFixed = node => {\n  var _node$props;\n  return ((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.fixed) === true;\n};\n\n/**\n * Get line index at given height\n *\n * @param {Object} node\n * @param {number} height\n */\nconst lineIndexAtHeight = (node, height) => {\n  let y = 0;\n  if (!node.lines) return 0;\n  for (let i = 0; i < node.lines.length; i += 1) {\n    const line = node.lines[i];\n    if (y + line.box.height > height) return i;\n    y += line.box.height;\n  }\n  return node.lines.length;\n};\n\n/**\n * Get height for given text line index\n *\n * @param {Object} node\n * @param {number} index\n */\nconst heightAtLineIndex = (node, index) => {\n  let counter = 0;\n  if (!node.lines) return counter;\n  for (let i = 0; i < index; i += 1) {\n    const line = node.lines[i];\n    if (!line) break;\n    counter += line.box.height;\n  }\n  return counter;\n};\n\nconst getLineBreak = (node, height) => {\n  const top = get(node, ['box', 'top'], 0);\n  const widows = get(node, ['props', 'widows'], 2);\n  const orphans = get(node, ['props', 'orphans'], 2);\n  const linesQuantity = node.lines.length;\n  const slicedLine = lineIndexAtHeight(node, height - top);\n  if (slicedLine === 0) {\n    return 0;\n  }\n  if (linesQuantity < orphans) {\n    return linesQuantity;\n  }\n  if (slicedLine < orphans || linesQuantity < orphans + widows) {\n    return 0;\n  }\n  if (linesQuantity === orphans + widows) {\n    return orphans;\n  }\n  if (linesQuantity - slicedLine < widows) {\n    return linesQuantity - widows;\n  }\n  return slicedLine;\n};\n\n// Also receives contentArea in case it's needed\nconst splitText = (node, height) => {\n  const slicedLineIndex = getLineBreak(node, height);\n  const currentHeight = heightAtLineIndex(node, slicedLineIndex);\n  const nextHeight = node.box.height - currentHeight;\n  const current = Object.assign({}, node, {\n    box: {\n      ...node.box,\n      height: currentHeight,\n      borderBottomWidth: 0\n    },\n    style: {\n      ...node.style,\n      marginBottom: 0,\n      paddingBottom: 0,\n      borderBottomWidth: 0,\n      borderBottomLeftRadius: 0,\n      borderBottomRightRadius: 0\n    },\n    lines: node.lines.slice(0, slicedLineIndex)\n  });\n  const next = Object.assign({}, node, {\n    box: {\n      ...node.box,\n      top: 0,\n      height: nextHeight,\n      borderTopWidth: 0\n    },\n    style: {\n      ...node.style,\n      marginTop: 0,\n      paddingTop: 0,\n      borderTopWidth: 0,\n      borderTopLeftRadius: 0,\n      borderTopRightRadius: 0\n    },\n    lines: node.lines.slice(slicedLineIndex)\n  });\n  return [current, next];\n};\n\nconst getTop$1 = node => {\n  var _node$box;\n  return ((_node$box = node.box) === null || _node$box === void 0 ? void 0 : _node$box.top) || 0;\n};\nconst hasFixedHeight = node => {\n  var _node$style;\n  return !isNil((_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style.height);\n};\nconst splitNode = (node, height) => {\n  if (!node) return [null, null];\n  const nodeTop = getTop$1(node);\n  const current = Object.assign({}, node, {\n    box: {\n      ...node.box,\n      borderBottomWidth: 0\n    },\n    style: {\n      ...node.style,\n      marginBottom: 0,\n      paddingBottom: 0,\n      borderBottomWidth: 0,\n      borderBottomLeftRadius: 0,\n      borderBottomRightRadius: 0\n    }\n  });\n  current.style.height = height - nodeTop;\n  const nextHeight = hasFixedHeight(node) ? node.box.height - (height - nodeTop) : null;\n  const next = Object.assign({}, node, {\n    box: {\n      ...node.box,\n      top: 0,\n      borderTopWidth: 0\n    },\n    style: {\n      ...node.style,\n      marginTop: 0,\n      paddingTop: 0,\n      borderTopWidth: 0,\n      borderTopLeftRadius: 0,\n      borderTopRightRadius: 0\n    }\n  });\n  if (nextHeight) {\n    next.style.height = nextHeight;\n  }\n  return [current, next];\n};\n\nconst NON_WRAP_TYPES = [P.Svg, P.Note, P.Image, P.Canvas];\nconst getWrap = node => {\n  var _node$props;\n  if (NON_WRAP_TYPES.includes(node.type)) return false;\n  return isNil((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.wrap) ? true : node.props.wrap;\n};\n\nconst getComputedPadding = (node, edge) => {\n  const {\n    yogaNode\n  } = node;\n  return yogaNode ? yogaNode.getComputedPadding(edge) : null;\n};\n\n/**\n * Get Yoga computed paddings. Zero otherwise\n *\n * @param {Object} node\n * @returns {{ paddingTop: number, paddingRight: number, paddingBottom: number, paddingLeft: number }} paddings\n */\nconst getPadding = node => {\n  const {\n    style,\n    box\n  } = node;\n  const paddingTop = getComputedPadding(node, Yoga.Edge.Top) || (box === null || box === void 0 ? void 0 : box.paddingTop) || (style === null || style === void 0 ? void 0 : style.paddingTop) || (style === null || style === void 0 ? void 0 : style.paddingVertical) || (style === null || style === void 0 ? void 0 : style.padding) || 0;\n  const paddingRight = getComputedPadding(node, Yoga.Edge.Right) || (box === null || box === void 0 ? void 0 : box.paddingRight) || (style === null || style === void 0 ? void 0 : style.paddingRight) || (style === null || style === void 0 ? void 0 : style.paddingHorizontal) || (style === null || style === void 0 ? void 0 : style.padding) || 0;\n  const paddingBottom = getComputedPadding(node, Yoga.Edge.Bottom) || (box === null || box === void 0 ? void 0 : box.paddingBottom) || (style === null || style === void 0 ? void 0 : style.paddingBottom) || (style === null || style === void 0 ? void 0 : style.paddingVertical) || (style === null || style === void 0 ? void 0 : style.padding) || 0;\n  const paddingLeft = getComputedPadding(node, Yoga.Edge.Left) || (box === null || box === void 0 ? void 0 : box.paddingLeft) || (style === null || style === void 0 ? void 0 : style.paddingLeft) || (style === null || style === void 0 ? void 0 : style.paddingHorizontal) || (style === null || style === void 0 ? void 0 : style.padding) || 0;\n  return {\n    paddingTop,\n    paddingRight,\n    paddingBottom,\n    paddingLeft\n  };\n};\n\nconst getWrapArea = page => {\n  var _page$style;\n  const {\n    paddingBottom\n  } = getPadding(page);\n  const height = (_page$style = page.style) === null || _page$style === void 0 ? void 0 : _page$style.height;\n  return height - paddingBottom;\n};\n\nconst getContentArea = page => {\n  var _page$style;\n  const height = (_page$style = page.style) === null || _page$style === void 0 ? void 0 : _page$style.height;\n  const {\n    paddingTop,\n    paddingBottom\n  } = getPadding(page);\n  return height - paddingBottom - paddingTop;\n};\n\nconst isString = value => typeof value === 'string';\nconst isNumber = value => typeof value === 'number';\nconst isFragment = value => value && value.type === Symbol.for('react.fragment');\n\n/**\n * Transforms a react element instance to internal element format.\n *\n * Can return multiple instances in the case of arrays or fragments.\n *\n * @param {Object} element React element\n * @returns {Object[]} parsed React elements\n */\nconst createInstances = element => {\n  if (!element) return [];\n  if (isString(element) || isNumber(element)) {\n    return [{\n      type: TextInstance,\n      value: `${element}`\n    }];\n  }\n  if (isFragment(element)) {\n    return createInstances(element.props.children);\n  }\n  if (Array.isArray(element)) {\n    return element.reduce((acc, el) => acc.concat(createInstances(el)), []);\n  }\n  if (!isString(element.type)) {\n    return createInstances(element.type(element.props));\n  }\n  const {\n    type,\n    props: {\n      style = {},\n      children = [],\n      ...props\n    }\n  } = element;\n  const nextChildren = castArray(children).reduce((acc, child) => acc.concat(createInstances(child)), []);\n  return [{\n    type,\n    style,\n    props,\n    box: {},\n    children: nextChildren\n  }];\n};\n\nconst getBreak = node => {\n  var _node$props;\n  return ((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.break) || false;\n};\nconst getMinPresenceAhead = node => {\n  var _node$props2;\n  return ((_node$props2 = node.props) === null || _node$props2 === void 0 ? void 0 : _node$props2.minPresenceAhead) || 0;\n};\nconst getFurthestEnd = elements => Math.max(...elements.map(node => node.box.top + node.box.height));\nconst getEndOfMinPresenceAhead = child => {\n  return child.box.top + child.box.height + child.box.marginBottom + getMinPresenceAhead(child);\n};\nconst getEndOfPresence = (child, futureElements) => {\n  const afterMinPresenceAhead = getEndOfMinPresenceAhead(child);\n  const endOfFurthestFutureElement = getFurthestEnd(futureElements.filter(node => {\n    var _node$props3;\n    return !((_node$props3 = node.props) !== null && _node$props3 !== void 0 && _node$props3.fixed);\n  }));\n  return Math.min(afterMinPresenceAhead, endOfFurthestFutureElement);\n};\nconst shouldBreak = (child, futureElements, height) => {\n  var _child$props;\n  if ((_child$props = child.props) !== null && _child$props !== void 0 && _child$props.fixed) return false;\n  const shouldSplit = height < child.box.top + child.box.height;\n  const canWrap = getWrap(child);\n\n  // Calculate the y coordinate where the desired presence of the child ends\n  const endOfPresence = getEndOfPresence(child, futureElements);\n  // If the child is already at the top of the page, breaking won't improve its presence\n  // (as long as react-pdf does not support breaking into differently sized containers)\n  const breakingImprovesPresence = child.box.top > child.box.marginTop;\n  return getBreak(child) || shouldSplit && !canWrap || !shouldSplit && endOfPresence > height && breakingImprovesPresence;\n};\n\nconst IGNORABLE_CODEPOINTS = [8232,\n// LINE_SEPARATOR\n8233 // PARAGRAPH_SEPARATOR\n];\nconst buildSubsetForFont = font => IGNORABLE_CODEPOINTS.reduce((acc, codePoint) => {\n  if (font && font.hasGlyphForCodePoint && font.hasGlyphForCodePoint(codePoint)) {\n    return acc;\n  }\n  return [...acc, String.fromCharCode(codePoint)];\n}, []);\nconst ignoreChars = fragments => fragments.map(fragment => {\n  const charSubset = buildSubsetForFont(fragment.attributes.font);\n  const subsetRegex = new RegExp(charSubset.join('|'));\n  return {\n    string: fragment.string.replace(subsetRegex, ''),\n    attributes: fragment.attributes\n  };\n});\n\nconst PREPROCESSORS = [ignoreChars, embedEmojis];\nconst isImage$1 = node => node.type === P.Image;\nconst isTextInstance$2 = node => node.type === P.TextInstance;\n\n/**\n * Get textkit fragments of given node object\n *\n * @param {Object} fontStore font store\n * @param {Object} instance node\n * @param {string} [parentLink] parent link\n * @param {number} [level] fragment level\n * @returns {Object[]} text fragments\n */\nconst getFragments = function (fontStore, instance, parentLink, level) {\n  var _instance$props, _instance$props2;\n  if (level === void 0) {\n    level = 0;\n  }\n  if (!instance) return [{\n    string: ''\n  }];\n  let fragments = [];\n  const {\n    color = 'black',\n    direction = 'ltr',\n    fontFamily = 'Helvetica',\n    fontWeight,\n    fontStyle,\n    fontSize = 18,\n    textAlign,\n    lineHeight,\n    textDecoration,\n    textDecorationColor,\n    textDecorationStyle,\n    textTransform,\n    letterSpacing,\n    textIndent,\n    opacity,\n    verticalAlign\n  } = instance.style;\n  const fontFamilies = typeof fontFamily === 'string' ? [fontFamily] : [...(fontFamily || [])];\n  const font = fontFamilies.map(fontFamilyName => {\n    if (typeof fontFamilyName !== 'string') return fontFamilyName;\n    const opts = {\n      fontFamily: fontFamilyName,\n      fontWeight,\n      fontStyle\n    };\n    const obj = fontStore ? fontStore.getFont(opts) : null;\n    return obj ? obj.data : fontFamilyName;\n  });\n\n  // Don't pass main background color to textkit. Will be rendered by the render package instead\n  const backgroundColor = level === 0 ? null : instance.style.backgroundColor;\n  const attributes = {\n    font,\n    color,\n    opacity,\n    fontSize,\n    lineHeight,\n    direction,\n    verticalAlign,\n    backgroundColor,\n    indent: textIndent,\n    characterSpacing: letterSpacing,\n    strikeStyle: textDecorationStyle,\n    underlineStyle: textDecorationStyle,\n    underline: textDecoration === 'underline' || textDecoration === 'underline line-through' || textDecoration === 'line-through underline',\n    strike: textDecoration === 'line-through' || textDecoration === 'underline line-through' || textDecoration === 'line-through underline',\n    strikeColor: textDecorationColor || color,\n    underlineColor: textDecorationColor || color,\n    link: parentLink || ((_instance$props = instance.props) === null || _instance$props === void 0 ? void 0 : _instance$props.src) || ((_instance$props2 = instance.props) === null || _instance$props2 === void 0 ? void 0 : _instance$props2.href),\n    align: textAlign || (direction === 'rtl' ? 'right' : 'left')\n  };\n  for (let i = 0; i < instance.children.length; i += 1) {\n    const child = instance.children[i];\n    if (isImage$1(child)) {\n      fragments.push({\n        string: String.fromCharCode(0xfffc),\n        attributes: {\n          ...attributes,\n          attachment: {\n            width: child.style.width || fontSize,\n            height: child.style.height || fontSize,\n            image: child.image.data\n          }\n        }\n      });\n    } else if (isTextInstance$2(child)) {\n      fragments.push({\n        string: transformText(child.value, textTransform),\n        attributes\n      });\n    } else if (child) {\n      fragments.push(...getFragments(fontStore, child, attributes.link, level + 1));\n    }\n  }\n  for (let i = 0; i < PREPROCESSORS.length; i += 1) {\n    const preprocessor = PREPROCESSORS[i];\n    fragments = preprocessor(fragments);\n  }\n  return fragments;\n};\n\n/**\n * Get textkit attributed string from text node\n *\n * @param {Object} fontStore font store\n * @param {Object} instance node\n * @returns {Object} attributed string\n */\nconst getAttributedString = (fontStore, instance) => {\n  const fragments = getFragments(fontStore, instance);\n  return fromFragments(fragments);\n};\n\nconst engines = {\n  bidi,\n  linebreaker,\n  justification,\n  textDecoration,\n  scriptItemizer,\n  wordHyphenation,\n  fontSubstitution\n};\nconst engine = layoutEngine(engines);\nconst getMaxLines = node => {\n  var _node$style;\n  return (_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style.maxLines;\n};\nconst getTextOverflow = node => {\n  var _node$style2;\n  return (_node$style2 = node.style) === null || _node$style2 === void 0 ? void 0 : _node$style2.textOverflow;\n};\n\n/**\n * Get layout container for specific text node\n *\n * @param {number} width\n * @param {number} height\n * @param {Object} node\n * @returns {Object} layout container\n */\nconst getContainer = (width, height, node) => {\n  const maxLines = getMaxLines(node);\n  const textOverflow = getTextOverflow(node);\n  return {\n    x: 0,\n    y: 0,\n    width,\n    maxLines,\n    height: height || Infinity,\n    truncateMode: textOverflow\n  };\n};\n\n/**\n * Get text layout options for specific text node\n *\n * @param {Object} node instance\n * @returns {Object} layout options\n */\nconst getLayoutOptions = (fontStore, node) => ({\n  hyphenationPenalty: node.props.hyphenationPenalty,\n  shrinkWhitespaceFactor: {\n    before: -0.5,\n    after: -0.5\n  },\n  hyphenationCallback: node.props.hyphenationCallback || (fontStore === null || fontStore === void 0 ? void 0 : fontStore.getHyphenationCallback()) || null\n});\n\n/**\n * Get text lines for given node\n *\n * @param {Object} node node\n * @param {number} width container width\n * @param {number} height container height\n * @param {number} fontStore font store\n * @returns {Object[]} layout lines\n */\nconst layoutText = (node, width, height, fontStore) => {\n  const attributedString = getAttributedString(fontStore, node);\n  const container = getContainer(width, height, node);\n  const options = getLayoutOptions(fontStore, node);\n  const lines = engine(attributedString, container, options);\n  return lines.reduce((acc, line) => [...acc, ...line], []);\n};\n\nconst isType$2 = type => node => node.type === type;\nconst isSvg$2 = isType$2(P.Svg);\nconst isText$4 = isType$2(P.Text);\nconst shouldIterate = node => !isSvg$2(node) && !isText$4(node);\nconst shouldLayoutText = node => isText$4(node) && !node.lines;\n\n/**\n * Performs text layout on text node if wasn't calculated before.\n * Text layout is usually performed on Yoga's layout process (via setMeasureFunc),\n * but we need to layout those nodes with fixed width and height.\n *\n * @param {Object} node\n * @returns {Object} layout node\n */\nconst resolveTextLayout = (node, fontStore) => {\n  if (shouldLayoutText(node)) {\n    const width = node.box.width - (node.box.paddingRight + node.box.paddingLeft);\n    const height = node.box.height - (node.box.paddingTop + node.box.paddingBottom);\n    node.lines = layoutText(node, width, height, fontStore);\n  }\n  if (shouldIterate(node)) {\n    if (!node.children) return node;\n    const mapChild = child => resolveTextLayout(child, fontStore);\n    const children = node.children.map(mapChild);\n    return Object.assign({}, node, {\n      children\n    });\n  }\n  return node;\n};\n\nconst BASE_INHERITABLE_PROPERTIES = ['color', 'fontFamily', 'fontSize', 'fontStyle', 'fontWeight', 'letterSpacing', 'opacity', 'textDecoration', 'textTransform', 'lineHeight', 'textAlign', 'visibility', 'wordSpacing'];\nconst TEXT_INHERITABLE_PROPERTIES = [...BASE_INHERITABLE_PROPERTIES, 'backgroundColor'];\nconst isSvg$1 = node => node.type === P.Svg;\nconst isText$3 = node => node.type === P.Text;\n\n// Merge style values\nconst mergeValues = (styleName, value, inheritedValue) => {\n  switch (styleName) {\n    case 'textDecoration':\n      {\n        // merge not none and not false textDecoration values to one rule\n        return [inheritedValue, value].filter(v => v && v !== 'none').join(' ');\n      }\n    default:\n      return value;\n  }\n};\n\n// Merge inherited and node styles\nconst merge = (inheritedStyles, style) => {\n  const mergedStyles = {\n    ...inheritedStyles\n  };\n  Object.entries(style).forEach(_ref => {\n    let [styleName, value] = _ref;\n    mergedStyles[styleName] = mergeValues(styleName, value, inheritedStyles[styleName]);\n  });\n  return mergedStyles;\n};\n\n/**\n * @typedef {Function} MergeStyles\n * @param {Object} node\n * @returns {Object} node with styles merged\n */\n\n/**\n * Merges styles with node\n *\n * @param {Object} inheritedStyles style object\n * @returns {MergeStyles} merge styles function\n */\nconst mergeStyles = inheritedStyles => node => {\n  const style = merge(inheritedStyles, node.style || {});\n  return Object.assign({}, node, {\n    style\n  });\n};\n\n/**\n * Inherit style values from the root to the leafs\n *\n * @param {Object} node document root\n * @returns {Object} document root with inheritance\n *\n */\nconst resolveInheritance = node => {\n  if (isSvg$1(node)) return node;\n  if (!node.children) return node;\n  const inheritableProperties = isText$3(node) ? TEXT_INHERITABLE_PROPERTIES : BASE_INHERITABLE_PROPERTIES;\n  const inheritStyles = pick(inheritableProperties, node.style || {});\n  const resolveChild = compose(resolveInheritance, mergeStyles(inheritStyles));\n  const children = node.children.map(resolveChild);\n  return Object.assign({}, node, {\n    children\n  });\n};\n\nconst getComputedMargin = (node, edge) => {\n  const {\n    yogaNode\n  } = node;\n  return yogaNode ? yogaNode.getComputedMargin(edge) : null;\n};\n\n/**\n * Get Yoga computed magins. Zero otherwise\n *\n * @param {Object} node\n * @returns {{ marginTop: number, marginRight: number, marginBottom: number, marginLeft: number }} margins\n */\nconst getMargin = node => {\n  const {\n    style,\n    box\n  } = node;\n  const marginTop = getComputedMargin(node, Yoga.Edge.Top) || (box === null || box === void 0 ? void 0 : box.marginTop) || (style === null || style === void 0 ? void 0 : style.marginTop) || (style === null || style === void 0 ? void 0 : style.marginVertical) || (style === null || style === void 0 ? void 0 : style.margin) || 0;\n  const marginRight = getComputedMargin(node, Yoga.Edge.Right) || (box === null || box === void 0 ? void 0 : box.marginRight) || (style === null || style === void 0 ? void 0 : style.marginRight) || (style === null || style === void 0 ? void 0 : style.marginHorizontal) || (style === null || style === void 0 ? void 0 : style.margin) || 0;\n  const marginBottom = getComputedMargin(node, Yoga.Edge.Bottom) || (box === null || box === void 0 ? void 0 : box.marginBottom) || (style === null || style === void 0 ? void 0 : style.marginBottom) || (style === null || style === void 0 ? void 0 : style.marginVertical) || (style === null || style === void 0 ? void 0 : style.margin) || 0;\n  const marginLeft = getComputedMargin(node, Yoga.Edge.Left) || (box === null || box === void 0 ? void 0 : box.marginLeft) || (style === null || style === void 0 ? void 0 : style.marginLeft) || (style === null || style === void 0 ? void 0 : style.marginHorizontal) || (style === null || style === void 0 ? void 0 : style.margin) || 0;\n  return {\n    marginTop,\n    marginRight,\n    marginBottom,\n    marginLeft\n  };\n};\n\n/**\n * Get Yoga computed position. Zero otherwise\n *\n * @param {Object} node\n * @returns {{ top: number, right: number, bottom: number, left: number }} position\n */\nconst getPosition = node => {\n  const {\n    yogaNode\n  } = node;\n  return {\n    top: (yogaNode === null || yogaNode === void 0 ? void 0 : yogaNode.getComputedTop()) || 0,\n    right: (yogaNode === null || yogaNode === void 0 ? void 0 : yogaNode.getComputedRight()) || 0,\n    bottom: (yogaNode === null || yogaNode === void 0 ? void 0 : yogaNode.getComputedBottom()) || 0,\n    left: (yogaNode === null || yogaNode === void 0 ? void 0 : yogaNode.getComputedLeft()) || 0\n  };\n};\n\nconst DEFAULT_DIMENSION = {\n  width: 0,\n  height: 0\n};\n\n/**\n * Get Yoga computed dimensions. Zero otherwise\n *\n * @param {Object} node\n * @returns {{ width: number, height: number }} dimensions\n */\nconst getDimension = node => {\n  const {\n    yogaNode\n  } = node;\n  if (!yogaNode) return DEFAULT_DIMENSION;\n  return {\n    width: yogaNode.getComputedWidth(),\n    height: yogaNode.getComputedHeight()\n  };\n};\n\nconst getComputedBorder = (yogaNode, edge) => yogaNode ? yogaNode.getComputedBorder(edge) : 0;\n\n/**\n * Get Yoga computed border width. Zero otherwise\n *\n * @param {Object} node\n * @returns {{ borderTopWidth: number, borderRightWidth: number, borderBottomWidth: number, borderLeftWidth: number }} border widths\n */\nconst getBorderWidth = node => {\n  const {\n    yogaNode\n  } = node;\n  return {\n    borderTopWidth: getComputedBorder(yogaNode, Yoga.Edge.Top),\n    borderRightWidth: getComputedBorder(yogaNode, Yoga.Edge.Right),\n    borderBottomWidth: getComputedBorder(yogaNode, Yoga.Edge.Bottom),\n    borderLeftWidth: getComputedBorder(yogaNode, Yoga.Edge.Left)\n  };\n};\n\n/**\n * @typedef {Function} NodeInstanceWrapper\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\n\n/**\n * Set display attribute to node's Yoga instance\n *\n * @param {string} value display\n * @returns {NodeInstanceWrapper} node instance wrapper\n */\nconst setDisplay = value => node => {\n  const {\n    yogaNode\n  } = node;\n  if (yogaNode) {\n    yogaNode.setDisplay(value === 'none' ? Yoga.Display.None : Yoga.Display.Flex);\n  }\n  return node;\n};\n\nconst OVERFLOW = {\n  hidden: Yoga.Overflow.Hidden,\n  scroll: Yoga.Overflow.Scroll\n};\n\n/**\n * @typedef {Function} NodeInstanceWrapper\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\n\n/**\n * Set overflow attribute to node's Yoga instance\n *\n * @param {string} value overflow value\n * @returns {NodeInstanceWrapper} node instance wrapper\n */\nconst setOverflow = value => node => {\n  const {\n    yogaNode\n  } = node;\n  if (!isNil(value) && yogaNode) {\n    const overflow = OVERFLOW[value] || Yoga.Overflow.Visible;\n    yogaNode.setOverflow(overflow);\n  }\n  return node;\n};\n\nconst FLEX_WRAP = {\n  wrap: Yoga.Wrap.Wrap,\n  'wrap-reverse': Yoga.Wrap.WrapReverse\n};\n\n/**\n * @typedef {Function} NodeInstanceWrapper\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\n\n/**\n * Set flex wrap attribute to node's Yoga instance\n *\n * @param {string} value flex wrap value\n * @returns {NodeInstanceWrapper} node instance wrapper\n */\nconst setFlexWrap = value => node => {\n  const {\n    yogaNode\n  } = node;\n  if (yogaNode) {\n    const flexWrap = FLEX_WRAP[value] || Yoga.Wrap.NoWrap;\n    yogaNode.setFlexWrap(flexWrap);\n  }\n  return node;\n};\n\n/**\n * @typedef {Function} NodeInstanceWrapper\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\n\n/**\n * @typedef {Function} YogaValueSetter\n * @param {any} value\n * @returns {NodeInstanceWrapper} node instance wrapper\n */\n\n/**\n * Set generic yoga attribute to node's Yoga instance, handing `auto`, edges and percentage cases\n *\n * @param {string} attr property\n * @param {number} [edge] edge\n * @returns {YogaValueSetter} node instance wrapper\n */\nconst setYogaValue = (attr, edge) => value => node => {\n  const {\n    yogaNode\n  } = node;\n  if (!isNil(value) && yogaNode) {\n    const hasEdge = !isNil(edge);\n    const fixedMethod = `set${upperFirst(attr)}`;\n    const autoMethod = `${fixedMethod}Auto`;\n    const percentMethod = `${fixedMethod}Percent`;\n    const percent = matchPercent(value);\n    if (percent && !yogaNode[percentMethod]) {\n      throw new Error(`You can't pass percentage values to ${attr} property`);\n    }\n    if (percent) {\n      if (hasEdge) {\n        var _yogaNode$percentMeth;\n        (_yogaNode$percentMeth = yogaNode[percentMethod]) === null || _yogaNode$percentMeth === void 0 ? void 0 : _yogaNode$percentMeth.call(yogaNode, edge, percent.value);\n      } else {\n        var _yogaNode$percentMeth2;\n        (_yogaNode$percentMeth2 = yogaNode[percentMethod]) === null || _yogaNode$percentMeth2 === void 0 ? void 0 : _yogaNode$percentMeth2.call(yogaNode, percent.value);\n      }\n    } else if (value === 'auto') {\n      if (hasEdge) {\n        var _yogaNode$autoMethod;\n        (_yogaNode$autoMethod = yogaNode[autoMethod]) === null || _yogaNode$autoMethod === void 0 ? void 0 : _yogaNode$autoMethod.call(yogaNode, edge);\n      } else {\n        var _yogaNode$autoMethod2;\n        (_yogaNode$autoMethod2 = yogaNode[autoMethod]) === null || _yogaNode$autoMethod2 === void 0 ? void 0 : _yogaNode$autoMethod2.call(yogaNode);\n      }\n    } else if (hasEdge) {\n      var _yogaNode$fixedMethod;\n      (_yogaNode$fixedMethod = yogaNode[fixedMethod]) === null || _yogaNode$fixedMethod === void 0 ? void 0 : _yogaNode$fixedMethod.call(yogaNode, edge, value);\n    } else {\n      var _yogaNode$fixedMethod2;\n      (_yogaNode$fixedMethod2 = yogaNode[fixedMethod]) === null || _yogaNode$fixedMethod2 === void 0 ? void 0 : _yogaNode$fixedMethod2.call(yogaNode, value);\n    }\n  }\n  return node;\n};\n\n/**\n * @typedef {Function} NodeInstanceWrapper\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\n\n/**\n * Set flex grow attribute to node's Yoga instance\n *\n * @param {number} value flex grow value\n * @returns {NodeInstanceWrapper} node instance wrapper\n */\nconst setFlexGrow = value => node => {\n  return setYogaValue('flexGrow')(value || 0)(node);\n};\n\n/**\n * Set flex basis attribute to node's Yoga instance\n *\n * @param {number} flex basis value\n * @param {Object} node instance\n * @returns {Object} node instance\n */\nconst setFlexBasis = setYogaValue('flexBasis');\n\nconst ALIGN = {\n  'flex-start': Yoga.Align.FlexStart,\n  center: Yoga.Align.Center,\n  'flex-end': Yoga.Align.FlexEnd,\n  stretch: Yoga.Align.Stretch,\n  baseline: Yoga.Align.Baseline,\n  'space-between': Yoga.Align.SpaceBetween,\n  'space-around': Yoga.Align.SpaceAround,\n  'space-evenly': Yoga.Align.SpaceEvenly\n};\n\n/**\n * @typedef {Function} NodeInstanceWrapper\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\n\n/**\n * @typedef {Function} AlignSetter\n * @param {string} value align value\n * @returns {NodeInstanceWrapper} node instance wrapper\n */\n\n/**\n * Set generic align attribute to node's Yoga instance\n *\n * @param {string} attr specific align property\n * @returns {AlignSetter} align setter\n */\nconst setAlign = attr => value => node => {\n  const {\n    yogaNode\n  } = node;\n  const defaultValue = attr === 'items' ? Yoga.Align.Stretch : Yoga.Align.Auto;\n  if (yogaNode) {\n    const align = ALIGN[value] || defaultValue;\n    yogaNode[`setAlign${upperFirst(attr)}`](align);\n  }\n  return node;\n};\n\n/**\n * Set align self attribute to node's Yoga instance\n *\n * @param {string} align value\n * @param {Object} node instance\n * @returns {Object} node instance\n */\nconst setAlignSelf = setAlign('self');\n\n/**\n * Set align items attribute to node's Yoga instance\n *\n * @param {string} align value\n * @param {Object} node instance\n * @returns {Object} node instance\n */\nconst setAlignItems = setAlign('items');\n\n/**\n * @typedef {Function} NodeInstanceWrapper\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\n\n/**\n * Set flex shrink attribute to node's Yoga instance\n *\n * @param {number} value flex shrink value\n * @returns {NodeInstanceWrapper} node instance wrapper\n */\nconst setFlexShrink = value => node => {\n  return setYogaValue('flexShrink')(value || 1)(node);\n};\n\n/**\n * @typedef {Function} NodeInstanceWrapper\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\n\n/**\n * Set aspect ratio attribute to node's Yoga instance\n *\n * @param {number} value ratio\n * @returns {NodeInstanceWrapper} node instance wrapper\n */\nconst setAspectRatio = value => node => {\n  const {\n    yogaNode\n  } = node;\n  if (!isNil(value) && yogaNode) {\n    yogaNode.setAspectRatio(value);\n  }\n  return node;\n};\n\n/**\n * Set align content attribute to node's Yoga instance\n *\n * @param {string} align value\n * @param {Object} node instance\n * @returns {Object} node instance\n */\nconst setAlignContent = setAlign('content');\n\nconst POSITION = {\n  absolute: Yoga.PositionType.Absolute,\n  relative: Yoga.PositionType.Relative,\n  static: Yoga.PositionType.Static\n};\n\n/**\n * @typedef {Function} NodeInstanceWrapper\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\n\n/**\n * Set position type attribute to node's Yoga instance\n *\n * @param {string} value position position type\n * @returns {NodeInstanceWrapper} node instance wrapper\n */\nconst setPositionType = value => node => {\n  const {\n    yogaNode\n  } = node;\n  if (!isNil(value) && yogaNode) {\n    yogaNode.setPositionType(POSITION[value]);\n  }\n  return node;\n};\n\nconst FLEX_DIRECTIONS = {\n  row: Yoga.FlexDirection.Row,\n  'row-reverse': Yoga.FlexDirection.RowReverse,\n  'column-reverse': Yoga.FlexDirection.ColumnReverse\n};\n\n/**\n * @typedef {Function} NodeInstanceWrapper\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\n\n/**\n * Set flex direction attribute to node's Yoga instance\n *\n * @param {string} value flex direction value\n * @returns {NodeInstanceWrapper} node instance wrapper\n */\nconst setFlexDirection = value => node => {\n  const {\n    yogaNode\n  } = node;\n  if (yogaNode) {\n    const flexDirection = FLEX_DIRECTIONS[value] || Yoga.FlexDirection.Column;\n    yogaNode.setFlexDirection(flexDirection);\n  }\n  return node;\n};\n\nconst JUSTIFY_CONTENT = {\n  center: Yoga.Justify.Center,\n  'flex-end': Yoga.Justify.FlexEnd,\n  'space-between': Yoga.Justify.SpaceBetween,\n  'space-around': Yoga.Justify.SpaceAround,\n  'space-evenly': Yoga.Justify.SpaceEvenly\n};\n\n/**\n * @typedef {Function} NodeInstanceWrapper\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\n\n/**\n * Set justify content attribute to node's Yoga instance\n *\n * @param {string} value justify content value\n * @returns {NodeInstanceWrapper} node instance wrapper\n */\nconst setJustifyContent = value => node => {\n  const {\n    yogaNode\n  } = node;\n  if (!isNil(value) && yogaNode) {\n    const justifyContent = JUSTIFY_CONTENT[value] || Yoga.Justify.FlexStart;\n    yogaNode.setJustifyContent(justifyContent);\n  }\n  return node;\n};\n\n/**\n * @typedef {Function} NodeInstanceWrapper\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\n\n/**\n * Set margin top attribute to node's Yoga instance\n *\n * @param {number} margin margin top\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\nconst setMarginTop = setYogaValue('margin', Yoga.Edge.Top);\n\n/**\n * Set margin right attribute to node's Yoga instance\n *\n * @param {number} margin margin right\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\nconst setMarginRight = setYogaValue('margin', Yoga.Edge.Right);\n\n/**\n * Set margin bottom attribute to node's Yoga instance\n *\n * @param {number} margin margin bottom\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\nconst setMarginBottom = setYogaValue('margin', Yoga.Edge.Bottom);\n\n/**\n * Set margin left attribute to node's Yoga instance\n *\n * @param {number} margin margin left\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\nconst setMarginLeft = setYogaValue('margin', Yoga.Edge.Left);\n\n/**\n * @typedef {Function} NodeInstanceWrapper\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\n\n/**\n * Set padding top attribute to node's Yoga instance\n *\n * @param {number} padding padding top\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\nconst setPaddingTop = setYogaValue('padding', Yoga.Edge.Top);\n\n/**\n * Set padding right attribute to node's Yoga instance\n *\n * @param {number} padding padding right\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\nconst setPaddingRight = setYogaValue('padding', Yoga.Edge.Right);\n\n/**\n * Set padding bottom attribute to node's Yoga instance\n *\n * @param {number} padding padding bottom\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\nconst setPaddingBottom = setYogaValue('padding', Yoga.Edge.Bottom);\n\n/**\n * Set padding left attribute to node's Yoga instance\n *\n * @param {number} padding padding left\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\nconst setPaddingLeft = setYogaValue('padding', Yoga.Edge.Left);\n\n/**\n * @typedef {Function} NodeInstanceWrapper\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\n\n/**\n * Set border top attribute to node's Yoga instance\n *\n * @param {number} border border top width\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\nconst setBorderTop = setYogaValue('border', Yoga.Edge.Top);\n\n/**\n * Set border right attribute to node's Yoga instance\n *\n * @param {number} border border right width\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\nconst setBorderRight = setYogaValue('border', Yoga.Edge.Right);\n\n/**\n * Set border bottom attribute to node's Yoga instance\n *\n * @param {number} border border bottom width\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\nconst setBorderBottom = setYogaValue('border', Yoga.Edge.Bottom);\n\n/**\n * Set border left attribute to node's Yoga instance\n *\n * @param {number} border border left width\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\nconst setBorderLeft = setYogaValue('border', Yoga.Edge.Left);\n\n/**\n * @typedef {Function} NodeInstanceWrapper\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\n\n/**\n * Set position top attribute to node's Yoga instance\n *\n * @param {number} position position top\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\nconst setPositionTop = setYogaValue('position', Yoga.Edge.Top);\n\n/**\n * Set position right attribute to node's Yoga instance\n *\n * @param {number} position position right\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\nconst setPositionRight = setYogaValue('position', Yoga.Edge.Right);\n\n/**\n * Set position bottom attribute to node's Yoga instance\n *\n * @param {number} position position bottom\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\nconst setPositionBottom = setYogaValue('position', Yoga.Edge.Bottom);\n\n/**\n * Set position left attribute to node's Yoga instance\n *\n * @param {number} position position left\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\nconst setPositionLeft = setYogaValue('position', Yoga.Edge.Left);\n\n/**\n * Set width to node's Yoga instance\n *\n * @param {number} width\n * @param {Object} node instance\n * @returns {Object} node instance\n */\nconst setWidth = setYogaValue('width');\n\n/**\n * Set min width to node's Yoga instance\n *\n * @param {number} min width\n * @param {Object} node instance\n * @returns {Object} node instance\n */\nconst setMinWidth = setYogaValue('minWidth');\n\n/**\n * Set max width to node's Yoga instance\n *\n * @param {number} max width\n * @param {Object} node instance\n * @returns {Object} node instance\n */\nconst setMaxWidth = setYogaValue('maxWidth');\n\n/**\n * Set height to node's Yoga instance\n *\n * @param {number} height\n * @param {Object} node instance\n * @returns {Object} node instance\n */\nconst setHeight = setYogaValue('height');\n\n/**\n * Set min height to node's Yoga instance\n *\n * @param {number} min height\n * @param {Object} node instance\n * @returns {Object} node instance\n */\nconst setMinHeight = setYogaValue('minHeight');\n\n/**\n * Set max height to node's Yoga instance\n *\n * @param {number} max height\n * @param {Object} node instance\n * @returns {Object} node instance\n */\nconst setMaxHeight = setYogaValue('maxHeight');\n\n/**\n * @typedef {Function} NodeInstanceWrapper\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\n\n/**\n * Set rowGap value to node's Yoga instance\n *\n * @param {number} value gap value\n * @returns {NodeInstanceWrapper} node instance wrapper\n */\nconst setRowGap = value => node => {\n  const {\n    yogaNode\n  } = node;\n  if (!isNil(value) && yogaNode) {\n    yogaNode.setGap(Yoga.Gutter.Row, value);\n  }\n  return node;\n};\n\n/**\n * Set columnGap value to node's Yoga instance\n *\n * @param {number} value gap value\n * @returns {NodeInstanceWrapper} node instance wrapper\n */\nconst setColumnGap = value => node => {\n  const {\n    yogaNode\n  } = node;\n  if (!isNil(value) && yogaNode) {\n    yogaNode.setGap(Yoga.Gutter.Column, value);\n  }\n  return node;\n};\n\nconst getAspectRatio = viewbox => {\n  if (!viewbox) return null;\n  return (viewbox.maxX - viewbox.minX) / (viewbox.maxY - viewbox.minY);\n};\n\n/**\n * @typedef {Function} MeasureSvg\n * @param {number} width\n * @param {number} widthMode\n * @param {number} height\n * @param {number} heightMode\n * @returns {{ width: number, height: number }} svg width and height\n */\n\n/**\n * Yoga svg measure function\n *\n * @param {Object} page\n * @param {Object} node\n * @returns {MeasureSvg} measure svg\n */\nconst measureCanvas$1 = (page, node) => (width, widthMode, height, heightMode) => {\n  const aspectRatio = getAspectRatio(node.props.viewBox) || 1;\n  if (widthMode === Yoga.MeasureMode.Exactly || widthMode === Yoga.MeasureMode.AtMost) {\n    return {\n      width,\n      height: width / aspectRatio\n    };\n  }\n  if (heightMode === Yoga.MeasureMode.Exactly) {\n    return {\n      width: height * aspectRatio\n    };\n  }\n  return {};\n};\n\n/**\n * Get lines width (if any)\n *\n * @param {Object} node\n * @returns {number} lines width\n */\nconst linesWidth = node => {\n  if (!node.lines) return 0;\n  return Math.max(0, ...node.lines.map(line => line.xAdvance));\n};\n\n/**\n * Get lines height (if any)\n *\n * @param {Object} node\n * @returns {number} lines height\n */\nconst linesHeight = node => {\n  if (!node.lines) return -1;\n  return node.lines.reduce((acc, line) => acc + line.box.height, 0);\n};\n\nconst ALIGNMENT_FACTORS = {\n  center: 0.5,\n  right: 1\n};\n\n/**\n * @typedef {Function} MeasureText\n * @param {number} width\n * @param {number} widthMode\n * @param {number} height\n * @returns {{ width: number, height: number }} text width and height\n */\n\n/**\n * Yoga text measure function\n *\n * @param {Object} page\n * @param {Object} node\n * @param {Object} fontStore\n * @returns {MeasureText} measure text function\n */\nconst measureText = (page, node, fontStore) => (width, widthMode, height) => {\n  if (widthMode === Yoga.MeasureMode.Exactly) {\n    if (!node.lines) node.lines = layoutText(node, width, height, fontStore);\n    return {\n      height: linesHeight(node)\n    };\n  }\n  if (widthMode === Yoga.MeasureMode.AtMost) {\n    var _node$style;\n    const alignFactor = ALIGNMENT_FACTORS[(_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style.textAlign] || 0;\n    if (!node.lines) {\n      node.lines = layoutText(node, width, height, fontStore);\n      node.alignOffset = (width - linesWidth(node)) * alignFactor; // Compensate align in variable width containers\n    }\n    return {\n      height: linesHeight(node),\n      width: Math.min(width, linesWidth(node))\n    };\n  }\n  return {};\n};\n\n/**\n * Get image ratio\n *\n * @param {Object} node image node\n * @returns {number} image ratio\n */\nconst getRatio = node => {\n  var _node$image;\n  return (_node$image = node.image) !== null && _node$image !== void 0 && _node$image.data ? node.image.width / node.image.height : 1;\n};\n\n/**\n * Checks if page has auto height\n *\n * @param {Object} page\n * @returns {boolean} is page height auto\n */\nconst isHeightAuto = page => {\n  var _page$box;\n  return isNil((_page$box = page.box) === null || _page$box === void 0 ? void 0 : _page$box.height);\n};\n\nconst SAFETY_HEIGHT$1 = 10;\n\n/**\n * @typedef {Function} MeasureImage\n * @param {number} width\n * @param {number} widthMode\n * @param {number} height\n * @param {number} heightMode\n * @returns {{ width: number, height: number }} image width and height\n */\n\n/**\n * Yoga image measure function\n *\n * @param {Object} page page\n * @param {Object} node node\n * @returns {MeasureImage} measure image\n */\nconst measureImage = (page, node) => (width, widthMode, height, heightMode) => {\n  const imageRatio = getRatio(node);\n  const imageMargin = getMargin(node);\n  const pagePadding = getPadding(page);\n  const pageArea = isHeightAuto(page) ? Infinity : page.box.height - pagePadding.paddingTop - pagePadding.paddingBottom - imageMargin.marginTop - imageMargin.marginBottom - SAFETY_HEIGHT$1;\n\n  // Skip measure if image data not present yet\n  if (!node.image) return {\n    width: 0,\n    height: 0\n  };\n  if (widthMode === Yoga.MeasureMode.Exactly && heightMode === Yoga.MeasureMode.Undefined) {\n    const scaledHeight = width / imageRatio;\n    return {\n      height: Math.min(pageArea, scaledHeight)\n    };\n  }\n  if (heightMode === Yoga.MeasureMode.Exactly && (widthMode === Yoga.MeasureMode.AtMost || widthMode === Yoga.MeasureMode.Undefined)) {\n    return {\n      width: Math.min(height * imageRatio, width)\n    };\n  }\n  if (widthMode === Yoga.MeasureMode.Exactly && heightMode === Yoga.MeasureMode.AtMost) {\n    const scaledHeight = width / imageRatio;\n    return {\n      height: Math.min(height, pageArea, scaledHeight)\n    };\n  }\n  if (widthMode === Yoga.MeasureMode.AtMost && heightMode === Yoga.MeasureMode.AtMost) {\n    if (imageRatio > 1) {\n      return {\n        width,\n        height: Math.min(width / imageRatio, height)\n      };\n    }\n    return {\n      height,\n      width: Math.min(height * imageRatio, width)\n    };\n  }\n  return {\n    height,\n    width\n  };\n};\n\nconst SAFETY_HEIGHT = 10;\nconst getMax = values => Math.max(-Infinity, ...values);\n\n/**\n * Helper object to predict canvas size\n * TODO: Implement remaining functions (as close as possible);\n */\nconst measureCtx = () => {\n  const ctx = {};\n  const points = [];\n  const nil = () => ctx;\n  const addPoint = (x, y) => points.push([x, y]);\n  const moveTo = function () {\n    addPoint(...arguments);\n    return ctx;\n  };\n  const rect = (x, y, w, h) => {\n    addPoint(x, y);\n    addPoint(x + w, y);\n    addPoint(x, y + h);\n    addPoint(x + w, y + h);\n    return ctx;\n  };\n  const ellipse = (x, y, rx, ry) => {\n    ry = ry || rx;\n    addPoint(x - rx, y - ry);\n    addPoint(x + rx, y - ry);\n    addPoint(x + rx, y + ry);\n    addPoint(x - rx, y + ry);\n    return ctx;\n  };\n  const polygon = function () {\n    points.push(...arguments);\n    return ctx;\n  };\n\n  // Change dimensions\n  ctx.rect = rect;\n  ctx.moveTo = moveTo;\n  ctx.lineTo = moveTo;\n  ctx.circle = ellipse;\n  ctx.polygon = polygon;\n  ctx.ellipse = ellipse;\n  ctx.roundedRect = rect;\n\n  // To be implemented\n  ctx.text = nil;\n  ctx.path = nil;\n  ctx.lineWidth = nil;\n  ctx.bezierCurveTo = nil;\n  ctx.quadraticCurveTo = nil;\n  ctx.scale = nil;\n  ctx.rotate = nil;\n  ctx.translate = nil;\n\n  // These don't change dimensions\n  ctx.dash = nil;\n  ctx.clip = nil;\n  ctx.save = nil;\n  ctx.fill = nil;\n  ctx.font = nil;\n  ctx.stroke = nil;\n  ctx.lineCap = nil;\n  ctx.opacity = nil;\n  ctx.restore = nil;\n  ctx.lineJoin = nil;\n  ctx.fontSize = nil;\n  ctx.fillColor = nil;\n  ctx.miterLimit = nil;\n  ctx.strokeColor = nil;\n  ctx.fillOpacity = nil;\n  ctx.strokeOpacity = nil;\n  ctx.linearGradient = nil;\n  ctx.radialGradient = nil;\n  ctx.getWidth = () => getMax(points.map(p => p[0]));\n  ctx.getHeight = () => getMax(points.map(p => p[1]));\n  return ctx;\n};\n\n/**\n * @typedef {Function} MeasureCanvas\n * @returns {{ width: number, height: number }} canvas width and height\n */\n\n/**\n * Yoga canvas measure function\n *\n * @param {Object} page\n * @param {Object} node\n * @returns {MeasureCanvas} measure canvas\n */\nconst measureCanvas = (page, node) => () => {\n  const imageMargin = getMargin(node);\n  const pagePadding = getPadding(page);\n  const pageArea = isHeightAuto(page) ? Infinity : page.box.height - pagePadding.paddingTop - pagePadding.paddingBottom - imageMargin.marginTop - imageMargin.marginBottom - SAFETY_HEIGHT;\n  const ctx = measureCtx();\n  node.props.paint(ctx);\n  const width = ctx.getWidth();\n  const height = Math.min(pageArea, ctx.getHeight());\n  return {\n    width,\n    height\n  };\n};\n\nconst isType$1 = type => node => node.type === type;\nconst isSvg = isType$1(P.Svg);\nconst isText$2 = isType$1(P.Text);\nconst isNote = isType$1(P.Note);\nconst isPage = isType$1(P.Page);\nconst isImage = isType$1(P.Image);\nconst isCanvas = isType$1(P.Canvas);\nconst isTextInstance$1 = isType$1(P.TextInstance);\nconst setNodeHeight = node => {\n  const value = isPage(node) ? node.box.height : node.style.height;\n  return setHeight(value);\n};\n\n/**\n * Set styles valeus into yoga node before layout calculation\n *\n * @param {Object} node\n * @returns {Object} node\n */\nconst setYogaValues = node => {\n  compose(setNodeHeight(node), setWidth(node.style.width), setMinWidth(node.style.minWidth), setMaxWidth(node.style.maxWidth), setMinHeight(node.style.minHeight), setMaxHeight(node.style.maxHeight), setMarginTop(node.style.marginTop), setMarginRight(node.style.marginRight), setMarginBottom(node.style.marginBottom), setMarginLeft(node.style.marginLeft), setPaddingTop(node.style.paddingTop), setPaddingRight(node.style.paddingRight), setPaddingBottom(node.style.paddingBottom), setPaddingLeft(node.style.paddingLeft), setPositionType(node.style.position), setPositionTop(node.style.top), setPositionRight(node.style.right), setPositionBottom(node.style.bottom), setPositionLeft(node.style.left), setBorderTop(node.style.borderTopWidth), setBorderRight(node.style.borderRightWidth), setBorderBottom(node.style.borderBottomWidth), setBorderLeft(node.style.borderLeftWidth), setDisplay(node.style.display), setFlexDirection(node.style.flexDirection), setAlignSelf(node.style.alignSelf), setAlignContent(node.style.alignContent), setAlignItems(node.style.alignItems), setJustifyContent(node.style.justifyContent), setFlexWrap(node.style.flexWrap), setOverflow(node.style.overflow), setAspectRatio(node.style.aspectRatio), setFlexBasis(node.style.flexBasis), setFlexGrow(node.style.flexGrow), setFlexShrink(node.style.flexShrink), setRowGap(node.style.rowGap), setColumnGap(node.style.columnGap))(node);\n};\n\n/**\n * @typedef {Function} InsertYogaNodes\n * @param {Object} child child node\n * @returns {Object} node\n */\n\n/**\n * Inserts child into parent' yoga node\n *\n * @param {Object} parent parent\n * @returns {InsertYogaNodes} insert yoga nodes\n */\nconst insertYogaNodes = parent => child => {\n  parent.insertChild(child.yogaNode, parent.getChildCount());\n  return child;\n};\nconst setMeasureFunc = (node, page, fontStore) => {\n  const {\n    yogaNode\n  } = node;\n  if (isText$2(node)) {\n    yogaNode.setMeasureFunc(measureText(page, node, fontStore));\n  }\n  if (isImage(node)) {\n    yogaNode.setMeasureFunc(measureImage(page, node));\n  }\n  if (isCanvas(node)) {\n    yogaNode.setMeasureFunc(measureCanvas(page, node));\n  }\n  if (isSvg(node)) {\n    yogaNode.setMeasureFunc(measureCanvas$1(page, node));\n  }\n  return node;\n};\nconst isLayoutElement = node => !isText$2(node) && !isNote(node) && !isSvg(node);\n\n/**\n * @typedef {Function} CreateYogaNodes\n * @param {Object} node\n * @returns {Object} node with appended yoga node\n */\n\n/**\n * Creates and add yoga node to document tree\n * Handles measure function for text and image nodes\n *\n * @returns {CreateYogaNodes} create yoga nodes\n */\nconst createYogaNodes = (page, fontStore, yoga) => node => {\n  const yogaNode = yoga.node.create();\n  const result = Object.assign({}, node, {\n    yogaNode\n  });\n  setYogaValues(result);\n  if (isLayoutElement(node) && node.children) {\n    const resolveChild = compose(insertYogaNodes(yogaNode), createYogaNodes(page, fontStore, yoga));\n    result.children = node.children.map(resolveChild);\n  }\n  setMeasureFunc(result, page, fontStore);\n  return result;\n};\n\n/**\n * Performs yoga calculation\n *\n * @param {Object} page page node\n * @returns {Object} page node\n */\nconst calculateLayout = page => {\n  page.yogaNode.calculateLayout();\n  return page;\n};\n\n/**\n * Saves Yoga layout result into 'box' attribute of node\n *\n * @param {Object} node\n * @returns {Object} node with box data\n */\nconst persistDimensions = node => {\n  if (isTextInstance$1(node)) return node;\n  const box = Object.assign(getPadding(node), getMargin(node), getBorderWidth(node), getPosition(node), getDimension(node));\n  const newNode = Object.assign({}, node, {\n    box\n  });\n  if (!node.children) return newNode;\n  const children = node.children.map(persistDimensions);\n  return Object.assign({}, newNode, {\n    children\n  });\n};\n\n/**\n * Removes yoga node from document tree\n *\n * @param {Object} node\n * @returns {Object} node without yoga node\n */\nconst destroyYogaNodes = node => {\n  const newNode = Object.assign({}, node);\n  delete newNode.yogaNode;\n  if (!node.children) return newNode;\n  const children = node.children.map(destroyYogaNodes);\n  return Object.assign({}, newNode, {\n    children\n  });\n};\n\n/**\n * Free yoga node from document tree\n *\n * @param {Object} node\n * @returns {Object} node without yoga node\n */\nconst freeYogaNodes = node => {\n  if (node.yogaNode) node.yogaNode.freeRecursive();\n  return node;\n};\n\n/**\n * Calculates page object layout using Yoga.\n * Takes node values from 'box' and 'style' attributes, and persist them back into 'box'\n * Destroy yoga values at the end.\n *\n * @param {Object} page object\n * @returns {Object} page object with correct 'box' layout attributes\n */\nconst resolvePageDimensions = (page, fontStore, yoga) => {\n  if (isNil(page)) return null;\n  return compose(destroyYogaNodes, freeYogaNodes, persistDimensions, calculateLayout, createYogaNodes(page, fontStore, yoga))(page);\n};\n\n/**\n * Calculates root object layout using Yoga.\n *\n * @param {Object} node root object\n * @param {Object} fontStore font store\n * @returns {Object} root object with correct 'box' layout attributes\n */\nconst resolveDimensions = (node, fontStore) => {\n  if (!node.children) return node;\n  const resolveChild = child => resolvePageDimensions(child, fontStore, node.yoga);\n  const children = node.children.map(resolveChild);\n  return Object.assign({}, node, {\n    children\n  });\n};\n\nconst isText$1 = node => node.type === P.Text;\n\n// Prevent splitting elements by low decimal numbers\nconst SAFETY_THRESHOLD = 0.001;\nconst assingChildren = (children, node) => Object.assign({}, node, {\n  children\n});\nconst getTop = node => {\n  var _node$box;\n  return ((_node$box = node.box) === null || _node$box === void 0 ? void 0 : _node$box.top) || 0;\n};\nconst allFixed = nodes => nodes.every(isFixed);\nconst isDynamic = node => {\n  var _node$props;\n  return !isNil((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.render);\n};\nconst relayoutPage = compose(resolveTextLayout, resolvePageDimensions, resolveInheritance, resolvePageStyles);\nconst warnUnavailableSpace = node => {\n  console.warn(`Node of type ${node.type} can't wrap between pages and it's bigger than available page height`);\n};\nconst splitNodes = (height, contentArea, nodes) => {\n  const currentChildren = [];\n  const nextChildren = [];\n  for (let i = 0; i < nodes.length; i += 1) {\n    const child = nodes[i];\n    const futureNodes = nodes.slice(i + 1);\n    const futureFixedNodes = futureNodes.filter(isFixed);\n    const nodeTop = getTop(child);\n    const nodeHeight = child.box.height;\n    const isOutside = height <= nodeTop;\n    const shouldBreak$1 = shouldBreak(child, futureNodes, height);\n    const shouldSplit = height + SAFETY_THRESHOLD < nodeTop + nodeHeight;\n    const canWrap = getWrap(child);\n    const fitsInsidePage = nodeHeight <= contentArea;\n    if (isFixed(child)) {\n      nextChildren.push(child);\n      currentChildren.push(child);\n      continue;\n    }\n    if (isOutside) {\n      const box = Object.assign({}, child.box, {\n        top: child.box.top - height\n      });\n      const next = Object.assign({}, child, {\n        box\n      });\n      nextChildren.push(next);\n      continue;\n    }\n    if (!fitsInsidePage && !canWrap) {\n      currentChildren.push(child);\n      nextChildren.push(...futureNodes);\n      warnUnavailableSpace(child);\n      break;\n    }\n    if (shouldBreak$1) {\n      const box = Object.assign({}, child.box, {\n        top: child.box.top - height\n      });\n      const props = Object.assign({}, child.props, {\n        wrap: true,\n        break: false\n      });\n      const next = Object.assign({}, child, {\n        box,\n        props\n      });\n      currentChildren.push(...futureFixedNodes);\n      nextChildren.push(next, ...futureNodes);\n      break;\n    }\n    if (shouldSplit) {\n      const [currentChild, nextChild] = split(child, height, contentArea);\n\n      // All children are moved to the next page, it doesn't make sense to show the parent on the current page\n      if (child.children.length > 0 && currentChild.children.length === 0) {\n        // But if the current page is empty then we can just include the parent on the current page\n        if (currentChildren.length === 0) {\n          currentChildren.push(child, ...futureFixedNodes);\n          nextChildren.push(...futureNodes);\n        } else {\n          const box = Object.assign({}, child.box, {\n            top: child.box.top - height\n          });\n          const next = Object.assign({}, child, {\n            box\n          });\n          currentChildren.push(...futureFixedNodes);\n          nextChildren.push(next, ...futureNodes);\n        }\n        break;\n      }\n      if (currentChild) currentChildren.push(currentChild);\n      if (nextChild) nextChildren.push(nextChild);\n      continue;\n    }\n    currentChildren.push(child);\n  }\n  return [currentChildren, nextChildren];\n};\nconst splitChildren = (height, contentArea, node) => {\n  const children = node.children || [];\n  const availableHeight = height - getTop(node);\n  return splitNodes(availableHeight, contentArea, children);\n};\nconst splitView = (node, height, contentArea) => {\n  const [currentNode, nextNode] = splitNode(node, height);\n  const [currentChilds, nextChildren] = splitChildren(height, contentArea, node);\n  return [assingChildren(currentChilds, currentNode), assingChildren(nextChildren, nextNode)];\n};\nconst split = (node, height, contentArea) => isText$1(node) ? splitText(node, height) : splitView(node, height, contentArea);\nconst shouldResolveDynamicNodes = node => {\n  const children = node.children || [];\n  return isDynamic(node) || children.some(shouldResolveDynamicNodes);\n};\nconst resolveDynamicNodes = (props, node) => {\n  const isNodeDynamic = isDynamic(node);\n\n  // Call render prop on dynamic nodes and append result to children\n  const resolveChildren = function (children) {\n    if (children === void 0) {\n      children = [];\n    }\n    if (isNodeDynamic) {\n      const res = node.props.render(props);\n      return createInstances(res).filter(Boolean).map(n => resolveDynamicNodes(props, n));\n    }\n    return children.map(c => resolveDynamicNodes(props, c));\n  };\n\n  // We reset dynamic text box so it can be computed again later on\n  const resetHeight = isNodeDynamic && isText$1(node);\n  const box = resetHeight ? {\n    ...node.box,\n    height: 0\n  } : node.box;\n  const children = resolveChildren(node.children);\n  const lines = isNodeDynamic ? null : node.lines;\n  return Object.assign({}, node, {\n    box,\n    lines,\n    children\n  });\n};\nconst resolveDynamicPage = (props, page, fontStore, yoga) => {\n  if (shouldResolveDynamicNodes(page)) {\n    const resolvedPage = resolveDynamicNodes(props, page);\n    return relayoutPage(resolvedPage, fontStore, yoga);\n  }\n  return page;\n};\nconst splitPage = (page, pageNumber, fontStore, yoga) => {\n  const wrapArea = getWrapArea(page);\n  const contentArea = getContentArea(page);\n  const dynamicPage = resolveDynamicPage({\n    pageNumber\n  }, page, fontStore, yoga);\n  const height = page.style.height;\n  const [currentChilds, nextChilds] = splitNodes(wrapArea, contentArea, dynamicPage.children);\n  const relayout = node => relayoutPage(node, fontStore, yoga);\n  const currentBox = {\n    ...page.box,\n    height\n  };\n  const currentPage = relayout(Object.assign({}, page, {\n    box: currentBox,\n    children: currentChilds\n  }));\n  if (nextChilds.length === 0 || allFixed(nextChilds)) return [currentPage, null];\n  const nextBox = omit('height', page.box);\n  const nextProps = omit('bookmark', page.props);\n  const nextPage = relayout(Object.assign({}, page, {\n    props: nextProps,\n    box: nextBox,\n    children: nextChilds\n  }));\n  return [currentPage, nextPage];\n};\nconst resolvePageIndices = (fontStore, yoga, page, pageNumber, pages) => {\n  const totalPages = pages.length;\n  const props = {\n    totalPages,\n    pageNumber: pageNumber + 1,\n    subPageNumber: page.subPageNumber + 1,\n    subPageTotalPages: page.subPageTotalPages\n  };\n  return resolveDynamicPage(props, page, fontStore, yoga);\n};\nconst assocSubPageData = subpages => {\n  return subpages.map((page, i) => ({\n    ...page,\n    subPageNumber: i,\n    subPageTotalPages: subpages.length\n  }));\n};\nconst dissocSubPageData = page => {\n  return omit(['subPageNumber', 'subPageTotalPages'], page);\n};\nconst paginate = (page, pageNumber, fontStore, yoga) => {\n  var _page$props;\n  if (!page) return [];\n  if (((_page$props = page.props) === null || _page$props === void 0 ? void 0 : _page$props.wrap) === false) return [page];\n  let splittedPage = splitPage(page, pageNumber, fontStore, yoga);\n  const pages = [splittedPage[0]];\n  let nextPage = splittedPage[1];\n  while (nextPage !== null) {\n    splittedPage = splitPage(nextPage, pageNumber + pages.length, fontStore, yoga);\n    pages.push(splittedPage[0]);\n    nextPage = splittedPage[1];\n  }\n  return pages;\n};\n\n/**\n * Performs pagination. This is the step responsible of breaking the whole document\n * into pages following pagiation rules, such as `fixed`, `break` and dynamic nodes.\n *\n * @param {Object} doc node\n * @param {Object} fontStore font store\n * @returns {Object} layout node\n */\nconst resolvePagination = (doc, fontStore) => {\n  let pages = [];\n  let pageNumber = 1;\n  for (let i = 0; i < doc.children.length; i += 1) {\n    const page = doc.children[i];\n    let subpages = paginate(page, pageNumber, fontStore, doc.yoga);\n    subpages = assocSubPageData(subpages);\n    pageNumber += subpages.length;\n    pages = pages.concat(subpages);\n  }\n  pages = pages.map(function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    return dissocSubPageData(resolvePageIndices(fontStore, doc.yoga, ...args));\n  });\n  return assingChildren(pages, doc);\n};\n\n/**\n * @typedef {Function} ResolvePageHorizontalPadding\n * @param {string} value padding value\n * @returns {Object} translated padding value\n */\n\n/**\n * Translates page percentage horizontal paddings in fixed ones\n *\n * @param {Object} container page container\n * @returns {ResolvePageHorizontalPadding} resolve page horizontal padding\n */\nconst resolvePageHorizontalPadding = container => value => {\n  const match = matchPercent(value);\n  return match ? match.percent * container.width : value;\n};\n\n/**\n * @typedef {Function} ResolvePageVerticalPadding\n * @param {string} padding value\n * @returns {Object} translated padding value\n */\n\n/**\n * Translates page percentage vertical paddings in fixed ones\n *\n * @param {Object} container page container\n * @returns {ResolvePageVerticalPadding} resolve page vertical padding\n */\nconst resolvePageVerticalPadding = container => value => {\n  const match = matchPercent(value);\n  return match ? match.percent * container.height : value;\n};\n\n/**\n * Translates page percentage paddings in fixed ones\n *\n * @param {Object} page\n * @returns {Object} page with fixed paddings\n */\nconst resolvePagePaddings = page => {\n  const container = page.style;\n  const style = evolve({\n    paddingTop: resolvePageVerticalPadding(container),\n    paddingLeft: resolvePageHorizontalPadding(container),\n    paddingRight: resolvePageHorizontalPadding(container),\n    paddingBottom: resolvePageVerticalPadding(container)\n  }, page.style);\n  return Object.assign({}, page, {\n    style\n  });\n};\n\n/**\n * Translates all pages percentage paddings in fixed ones\n * This has to be computed from pages calculated size and not by Yoga\n * because at this point we didn't performed pagination yet.\n *\n * @param {Object} root document root\n * @returns {Object} document root with translated page paddings\n */\nconst resolvePagesPaddings = root => {\n  if (!root.children) return root;\n  const children = root.children.map(resolvePagePaddings);\n  return Object.assign({}, root, {\n    children\n  });\n};\n\n/**\n * @typedef {Function} ResolveRadius\n * @param {string | number} value border radius value\n * @returns {number} resolved radius value\n */\n\n/**\n *\n * @param {{ width: number, height: number }} container width and height\n * @returns {ResolveRadius} resolve radius function\n */\nconst resolveRadius = container => value => {\n  if (!value) return undefined;\n  const match = matchPercent(value);\n  return match ? match.percent * Math.min(container.width, container.height) : value;\n};\n\n/**\n * Transforms percent border radius into fixed values\n *\n * @param {Object} node\n * @returns {Object} node\n */\nconst resolvePercentRadius = node => {\n  const style = evolve({\n    borderTopLeftRadius: resolveRadius(node.box),\n    borderTopRightRadius: resolveRadius(node.box),\n    borderBottomRightRadius: resolveRadius(node.box),\n    borderBottomLeftRadius: resolveRadius(node.box)\n  }, node.style || {});\n  const newNode = Object.assign({}, node, {\n    style\n  });\n  if (!node.children) return newNode;\n  const children = node.children.map(resolvePercentRadius);\n  return Object.assign({}, newNode, {\n    children\n  });\n};\n\n/**\n * Transform percent height into fixed\n *\n * @param {number} height\n * @returns {number} height\n */\nconst transformHeight = (pageArea, height) => {\n  const match = matchPercent(height);\n  return match ? match.percent * pageArea : height;\n};\n\n/**\n * Get page area (height minus paddings)\n *\n * @param {Object} page\n * @returns {number} page area\n */\nconst getPageArea = page => {\n  var _page$style, _page$style2;\n  const pageHeight = page.style.height;\n  const pagePaddingTop = ((_page$style = page.style) === null || _page$style === void 0 ? void 0 : _page$style.paddingTop) || 0;\n  const pagePaddingBottom = ((_page$style2 = page.style) === null || _page$style2 === void 0 ? void 0 : _page$style2.paddingBottom) || 0;\n  return pageHeight - pagePaddingTop - pagePaddingBottom;\n};\n\n/**\n * Transform node percent height to fixed\n *\n * @param {Object} page\n * @param {Object} node\n * @returns {Object} transformed node\n */\nconst resolveNodePercentHeight = (page, node) => {\n  var _page$style3, _node$style;\n  if (isNil((_page$style3 = page.style) === null || _page$style3 === void 0 ? void 0 : _page$style3.height)) return node;\n  if (isNil((_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style.height)) return node;\n  const pageArea = getPageArea(page);\n  const height = transformHeight(pageArea, node.style.height);\n  const style = Object.assign({}, node.style, {\n    height\n  });\n  return Object.assign({}, node, {\n    style\n  });\n};\n\n/**\n * Transform page immediate children with percent height to fixed\n *\n * @param {Object} page\n * @returns {Object} transformed page\n */\nconst resolvePagePercentHeight = page => {\n  if (!page.children) return page;\n  const resolveChild = child => resolveNodePercentHeight(page, child);\n  const children = page.children.map(resolveChild);\n  return Object.assign({}, page, {\n    children\n  });\n};\n\n/**\n * Transform all page immediate children with percent height to fixed.\n * This is needed for computing correct dimensions on pre-pagination layout.\n *\n * @param {Object} root document root\n * @returns {Object} transformed document root\n */\nconst resolvePercentHeight = root => {\n  if (!root.children) return root;\n  const children = root.children.map(resolvePagePercentHeight);\n  return Object.assign({}, root, {\n    children\n  });\n};\n\nconst isType = type => node => node.type === type;\nconst isLink = isType(P.Link);\nconst isText = isType(P.Text);\nconst isTextInstance = isType(P.TextInstance);\n\n/**\n * Checks if node has render prop\n *\n * @param {Object} node\n * @returns {boolean} has render prop?\n */\nconst hasRenderProp = node => {\n  var _node$props;\n  return !!((_node$props = node.props) !== null && _node$props !== void 0 && _node$props.render);\n};\n\n/**\n * Checks if node is text type (Text or TextInstance)\n *\n * @param {Object} node\n * @returns {boolean} are all children text instances?\n */\nconst isTextType = node => isText(node) || isTextInstance(node);\n\n/**\n * Checks if is tet link that needs to be wrapped in Text\n *\n * @param {Object} node\n * @returns {boolean} are all children text instances?\n */\nconst isTextLink = node => {\n  const children = node.children || [];\n\n  // Text string inside a Link\n  if (children.every(isTextInstance)) return true;\n\n  // Text node inside a Link\n  if (children.every(isText)) return false;\n  return children.every(isTextType);\n};\n\n/**\n * Wraps node children inside Text node\n *\n * @param {Object} node\n * @returns {boolean} node with intermediate Text child\n */\nconst wrapText = node => {\n  const textElement = {\n    type: P.Text,\n    props: {},\n    style: {},\n    box: {},\n    children: node.children\n  };\n  return Object.assign({}, node, {\n    children: [textElement]\n  });\n};\nconst transformLink = node => {\n  if (!isLink(node)) return node;\n\n  // If has render prop substitute the instance by a Text, that will\n  // ultimately render the inline Link via the textkit PDF renderer.\n  if (hasRenderProp(node)) return Object.assign({}, node, {\n    type: P.Text\n  });\n\n  // If is a text link (either contains Text or TextInstalce), wrap it\n  // inside a Text element so styles are applied correctly\n\n  if (isTextLink(node)) return wrapText(node);\n  return node;\n};\n\n/**\n * Transforms Link layout to correctly render text and dynamic rendered links\n *\n * @param {Object} node\n * @returns {Object} node with link substitution\n */\nconst resolveLinkSubstitution = node => {\n  if (!node.children) return node;\n  const resolveChild = compose(transformLink, resolveLinkSubstitution);\n  const children = node.children.map(resolveChild);\n  return Object.assign({}, node, {\n    children\n  });\n};\n\nconst layout = asyncCompose(resolveZIndex, resolveOrigin, resolveAssets, resolvePagination, resolveTextLayout, resolvePercentRadius, resolveDimensions, resolveSvg, resolveAssets, resolveInheritance, resolvePercentHeight, resolvePagesPaddings, resolveStyles, resolveLinkSubstitution, resolveBookmarks, resolvePageSizes, resolveYoga);\n\nexport { layout as default };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3480, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}